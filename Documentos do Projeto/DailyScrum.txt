--> Daily Scrum inicial:


- implementar a retirada da lista de parâmetros de uma função lisp como a SecondMemberList ---> implementado, modificado o método AvaliaParametros()--> aguardando testes.
 (o primeiro elemento é o nome da função, o segundo elemento é a lista de parâmetros, o terceiro elemento é a primeira instrução lisp da função,etc..
- implementar a retirada do corpo da função, com os novos métodos de retorno do enésimo elemento.---> implementado, modificado o método AvaliaFuncao()---> aguardando testes.

- modificado a instrução [if], com os novos método de acesso a próximas listas ---> implementado, testado positivamente.
- modificado o método AvaliaOperacaoMatematicaComListas()---> não codificado totalmente.

- NO GERAL, os método de acesso a próximas listas facilitam e muito, evita as operações sequenciais de car() e cdr(), resultando  num código mais legível e livre de erros vindos de car() e cdr().

------> o que falta para este dia:
	----> codificar totalmente o método AvaliaOperacaoMatematicaComListas().--> codificado, testado, fixado, resultados positivamente.método AvaliaOperacaoMatematica(), testado tb., resultado positivamente.
	----> testes para AvaliaParametros(), e AvaliaFuncao(). --> método AvaliaFuncao() retorna sem falhas para instruções básicas.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
----->  DailyScrum 30.04:
	---> testar a instrução [cond]. fixado, testado, positivamente.
	---> verificado as operações matemáticas para int e float, as operações matemáticas genéricas suporta os dois tipos de números.
	---> testar o método AvaliaParametros(). ---> testado com função com operações matemáticas dentro dos parâmetros, falha, 
		retorna apenas o resultado da lista de parâmetros, e não a função que chamou a avaliação da lista de parâmetros.
		Pode haver uma interferência de referência na lista, pois a avaliação dos parâmetros está funcionando, mas a chamada da função que tem como parâmetros o resultado da avaliação de parâmetros, não está trabalhando apropriadamente.
		--> fixado, a chamada de Avaliação de Parâmetros requer a lista de entrada da AvaliaFuncao(), mas a chamada de Avaliação requer como lista de instruções a definição da lista de entrada, no repositório de funções. ---> testado, fixado, trabalhando apropriadamente.
	---> testar o método AvaliaFuncao(), para funções lisp não básicas.---> o teste de Avaliação de parâmetros inclui a avaliação de funções lisp não básicas. (mas sem avaliação de funções lisp armazenadas como um operando numa expressão matemática).


----> graças ao foco no objetivos da Sprint Lisp, foi fixado e testado positivamente:
		---> instrução [cond].
		---> operações matemáticas, modificadas com a recodificação com métodos mais intuitivos, sem uso das funções car() e cdr().
		---> Avaliação de Parâmetros, para funções básicas e funções armazenadas no repositório.
		---> Avaliação de Funções, para funções básicas e funções compostas, com listas dentro dos parâmetros.---> o interessante foi que para avaliar os parâmetros, precisamos da chamada da função, exemplo: foo(- x 3), e para avaliarmos funções, precisamos da definição da função, exemplo: f(x


---> modificação no código de OperaçãoMatemática, agora um item da lista a ser avaliada pode ser um item-lista, que é avaliada em AvaliaFuncao().--> fixado, testado positivamente.

---> codificar a OperaçãoMatemática para comportar nomes de funções lisp armazenadas, podendo avaliar então listas como (fact(x) (if ((x>0) (* fact(- x 1) 1)), o fact(- x 1) é uma expressão de função armazenada que deve ser avaliada dentro de uma operação matemática.--> codificado, definido o teste, aguardando testes.

OBSERVAÇÃO:
---> depois de conhecer que a avaliação de parâmetros é feito com a lista-chamada (exemplo: foo(3)), e a avaliação da lista-instruções é feito com a definição da função (exemplo: foo(x)(+ x 1)), ficou muito claro e definido para codficar..

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
--->  DailyScrum 01.05:
	--> testar para operação matemática com nomes de funções lisp armazenadas.---> falha, instruções como (z), e parâmetros (z,2), não retorna 2, e sim (z).  ---> verificar o método SubstituiParametros, parece não estar funcionando apropriadamente.---> modificações em SubstituiParametros, a listalisp com parâmetro listado, tem o nome da átomo setado para (valorParametro, valorParametro).--> testado, falha, cálculo incorreto, a chamada (foo 1) em foo(z)(* z 3), com z=2, resulta em [6], e não [3]. Falha no método AvaliacaoFuncao(), e AvaliacaoParametros().
			---> fixado, havia um case que para uma lista de um só item, e parâmetro de um só item, retorna o valor do parâmetro.

	--> testar a instrução lisp [if], o código parece estar quebrado.---> fixado anteriormente, no momento que se percebeu que estava quebrado o método [if].--> testado positivamente.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

---> DailyScrum 02.05 
	---> testar avaliação de funções recursivas, com operações matemáticas contendo funções armazenadas no repositório.
	---> retirar das funções lisp os métodos cdr() e car() por GetEnesimaLista() e GetNextList(), é mais intuitivo e menos sujeito a erros de programação.
		---> retirado das funções lisp o método cdr(). Testes para [If] [Setq] [Member] [Cdr] [Car] testados positivamente. Falha função lisp para a função lisp [Cond]. Falha no processamento da lista currente.--> fixado a função [Cond], os valores dos operandos não estavam com números, e sim espaços vazios. ---> testado positivament
	---> teste para função recursiva com funções lisp como argumento para operações matemáticas. Falha, na operação multiplicaçãço, não há valor numérico, mas vazio ou símbolo.
		---> falha na obtenção dos parâmetros de chamada da função, o texto da chamada, como (recursive 1), não tem o nome do parâmetro, vindo da definição da função lisp a ser avaliada.--fixado.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
----> DailyScrum 07.05:
	--->codificado um método que extrai o valores (da lista de chamada da função) e os nomes (da lista de definição da função), para compor a lista de parâmetros.
		---> a testar. Não está muito claro, no caso de parâmetros ListaLISP, ou composição de uma instrução básica Lisp, se o método trabalhará corretamente.

	---> modificado o método obterlistUntilFinal(X), para o contador de X começar em 1, padronizando com o método GetEnesimaLista(X), que X também começa em 1. ---> testar as instruções lisp.



---> DailyScrum 09.05:
	---> regressão para uma função não recursiva, para testes do método AvaliaFuncao().
	---> quebra do método AvaliaFuncao(), chamada a AvaliaParametros() falhou.--> fixado, trabalha adequadamente para parâmetros que não são listasLisp, porém falta teste para parâmetros que contém listas dentro dos parâmetros.
	a linha de AvaliacaoParametros(), NO MÉTODO AvaliacaoFuncao() foi retirada:  parametros= AvaliaParametros(listaParametros, parametros);

       ---> fixado, testado, falha novamente, não está passando os parâmetros da entrada da função até a segunda instrução da lista (primeiro comando da função).
            falha na obtenção dos nomes do parâmetros, do método AvaliaFuncao().--> fixado, a obtenção de parâmetros para funções básicas foi fixado, o que se tem
            é que não há nomes para parâmetros de funções básica, exemplo: (+ 1 5 5) é a função básica a calcular, não há nomes para os valores da lista da função básica.---> fixado.

       ---> recodificado o método que avalia listas lisp dentro da lista de parâmetros de uma função (método AvaliacaoParametros()). codificado, testes falha, estoura o índice dentro do vetor de parâmetros.---> mais testes, o problema está na SubstituicaoDeParametros(), numa instrução GetEnesimaLista(), que retornava null ou vazia, em seguida fazia uma tentativa de percorrer as listas desta lista.GetEnesimaLista(). fixado, aguardando testes. fixado, método SubstituicaoParametros() está funcionando adequadamente, aguardando testes de AvaliacaoParametros().

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
----> DailyScrum 10.05
	---> testar método AvaliaParametros(). fixado, testado com função recursiva completa, falha, entra em loop infinito, pois um dos itens-lista dentro da função [recursive] é [recursive(- 1 1)] e que é avaliada, entrando em loop infinito.
		---> fixado, falha: os parâmetros não estão sendo carregados apropriadamente, em AvaliaFuncao().
		---> fixado, o método AvaliaFuncao() carrega os parâmetros apropriadamente, mas quando é chamado o carregamento de parâmetros conforme a lista de entrada, o algoritmo salta para um ponto aleatoriamente, vazamento de memória?
		---> continua o vazamento por referência, sobre as funções armazenadas no repositório!! O parãmetro não carrega apropriadamente porque o lugar do parâmetro está o valor do parâmetro calculado anteriormente.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> DailyScrum 11.05
	---> fixar os erros de SubstituiParametros(), vazamento de referências, e fixar os erros de AvaliaFuncao() para funções recursivas.

		---> fixado o vazamento de referências na classe RepositorioFuncoes, um novo método restaura os dados da função, a partir do texto de definição da função.
		---> testes do método AvaliaFuncao(), para uma função simples sem recursão, sem problemas.
		---> teste do método AvaLiaFuncao(), para funções recursivas, falha, o algortimo entra em loop infinito. Parece que o nome da função básica está sendo processada como função armazenada.
		---> fixado, mas há um bug na avaliação de uma lista condicional, no comando [if], ao pedir para avaliar a condicional, o resultado é sempre falso. O comando lisp para condicional, no caso [=] (igual) não trabalha apropriadamente.
		---> fixado o erro da condicional, o bug estava no método de ObterValorParaUmOperando(), que retornava um valor se o campo [valor] fosse igual a "". Fixado, o valor de campo troca de componentes do operando se o valor não for um número. ---> fixado, a função recursiva 2 funciona apropriadamente.

	----> atividades do DailyScrum completadas:
		---> SubstituiParametros(), que havia vazamento de referências, agora restaura a função a partir do texto da função, evitando vazamentos, que não foi encontrado.
		---> AvaliaFuncao(), funciona para funções lisp não recursivas, e para funções recursivas.
		---> um erro nos métodos condicionais, na validação de operandos, corrigindo, mudando de campo do átomo do operando se não for um número.


	----> uma questão interessante se levanta: e se a função lisp não trabalha com números, mas símbolos? (os métodos condicionais não encontrarão valores para símbolos, que não são números).
	----> atendendo o interesse do cliente, os métodos condificionais agora podem trabalha com símbolos (Átomos que não são números).
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
----> DailyScrum 12.05
	Atividades:
	---> teste para funções recursivas, mas com listas dentro da lista de chamada da função, como: foo(-(x 1) 1), foo(x y) (+ (x y)).
		---> testes para funções recursiva com listas de chamada dentro da lista de parâmetros. Falha, o método ObtemParametros() não está trabalhando para extrair os parâmetros.---> método ObtemParametros() codificado novamente, testes com funções simples e complexas bem sucedidas.
		---> fixado os métodos de obtenção de parâmetros ObtemParametros(), para comportar parâmetros que são funçoes lisp, armazenada ou básica. ----> aguardando testes---> testes bem sucedidos.
		---> quebrado o código do método AvaliaFuncao() para funções não recursivas. fixado, testes bem sucedidos.
		---> quebrado o código do método AvaliaFuncao() para funções recursivas. A aguardar fixação.--> fixado, testes para funções recursiva bem sucedidos.
	
	---> teste para funções recursivas, com lista de chamada com funções lisp dentro dos parãmetros da chamada.
		---> funcionalidade para avaliar funções dentro da lista de chamada da função, falha, AvaliaFuncao() quebrou com a nova funcionalidade.--> fixado, a lista de chamada estava embutida dentro de outra lista, como ((foo 1 5)), enquanto que o correto para avaliação é (foo 1 5).---> testes para funções simples passou.
		---> funcionalidade citada foi movida para a fora do método AvaliaFuncao(), mas não trabalhou adequadamente, para funções recursivas com lista de chamada de função composta por funções lisp.
		---> ante a muitos bugs, foi recodificado o método ObtemParametros() (não contém mais termos vindos de AvaliaFuncao(), que estava causando um loop infinito).---> aguardando testes.
		---> ante a muitos bugs sem solução visível, foi recodificado o método AvaliaParametros. ---> aguardando testes.
	O que falta:
		---> testar o método ObtemParametros().
		---> testar o método AvaliaFuncao().

	O que é para se pensar, sem a funcionalidade externa de avaliar a lista de chamada, o projeto original alcançou seu objetivo do Interpretador Lisp, com avaliação de listas lisp básicas ou armazenadas.
________________________________________________________________________________________________________________________________________________________________________________________________________________
---> DailyScrum 15.05
	---> testes feitos para ObtemParametros(), SubstiuicaoParametros(), e AvaliaFuncao(), fixados, testados positivamente.
	---> teste feito para chamada complexa com funções armazenadas e funções básicas, dentro da chamada à função, resultado positivamente.
	---> funcionalidade adicional testada positivamente, o que se pode ou não fazer é embutir chamadas complexas no método AvaliaFuncao().
_________________________________________________________________________________________________________________________________________________________________________________________________________________
---> DaiyScrum 30.05
	---> codificado o extrator de "templates" para sequência de IDs, a ser utilizado na construção de Escopo-Contextos.

---> DailyScrum 31.05
	----> codificando novamente a classe Escopo-Contexto, pois estava sujeito a muitos erros, e não é bem legível.  ---> a inserir novo código.---> pronto para inserir o código de BuildAllScopos().
	----> codificado métodos para obter e processar templates de sequencia ID,  a codificar a listagem de métodos tratadores, formando um novo núcleo de BuildEscopos().---> lista d métodos tratadores, completada, pronto para codificar BuildAllScopos().
	 ---> codificado todos métodos tratadores, e codificado o método BuildAllEscopos(), faltando o código de criação de escopos.

---> DailyScrum 01.06:
	-----> verificar código de métodos tratadores. verificado.
	-----> codificar a criação de novos escopos. codificado o esqueleto da criação de novos escopos.---> codificado.
	-----> modificar o código ID por ExpressaoID, quando necessário.---> modificado.
	-----> codificar a verificação de um ID se é uma Expressão ID. CODIFICADO  um método para registrar a expressão, na classe TabelaDeValores. bool RegistraExpressao(expressao, escopo), em que valida a expressão e coloca a expressão em PosOrdem.-->implementado.

_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> DailyScrum 02.06:	

	----> inicialização dos testes de obtenção de sequências id. falha, uma sequencia variante está sendo mal calculada.--> fixado, testado positivamente, mas falta um teste com sequencias variantes.
	----> a composição de sequencias ID está muito complexa,e sujeito a erros, codificação para que na malha de verificação de tokens, se contém tokens variantes, que são tratados na mesma malha de tokens. fixado, testado positivamente.
	----> refatoração do método de composição de sequencias, para um método GetSequenciasID(), que encontra listas de sequencia id original e sequencia id resumido.---> testado positivamente.

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> DailyScrum 03.06:	

	----> teste com sequencias constante presente. ---> testado positivamente.
	----> teste com sequencias variantes presente.---> fixado, testado positivamente.
	----> teste para obter expressões.

	---> ante as modificações no sistema de pontuação, os pontos calculados são o comprimento da lista de tokens resumidos achados e validados. ---> fixado, testado positivamente.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
--->  DailyScrum 04.06:

	----> teste para obter expressões.
	---> implantar no método BuildAllEscopos, os indices de metodos tratadores encontrados em PontuacaoSequenciaID();  ---> codificado, mas está com exceção, para poder complementar novos tokens-chave.
	----> codificar um nomo metodo da classe PosicaoECodigo, que achar a linha inicial de um grupo de tokens, entre um codigo (programa em linhas).---> codificado, aguardando testes.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
--->  DailyScrum 05.06:

	----> teste para obter expressões.--> codifcado, a testar com os métodos tratadores.
	----> o método PontuacaoSequencia() foi retirado o processamento de sequencias variantes, para simplificação dos testes. Testar com sequencias variantes inclusas na sequencia de entrada.---> testes feitos com sequencias variantes, falha, há um problema de retorno dos indices variantes, que estão se repetindo, devido o processamento ter que reiniciar depois de uma sequencia variante for encontrada.---> fixado, as sequencias variantes somente são tratadas quando há match de um token de sequencia principal. ----> fixado, testes positivamente.
	--->  testar o método BuildAllEscopos().   ---> método escopo foi refatorado, tornando mais simples de ler (legibilidade).  ---> modificado.
	--->  testar o método novo de determinação de posição do código. ---> testes feitos positivamente.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
--->  DailyScrum 05.06:

	---> método BuildAllEscopos() pronto para testar.
			---> iniciado os testes. Obtenção de indices dos metodos tratadores positivamente. Um detalhe é que os métodos tratadores foram feitos para analise com tokens como ID, OPERADOR,  etc..., quando deveria se uma análise sobre a sequencia original.---> fixado, aguardar a continuação de testes.
	----> testar o método BuildAllEscopos(). ----> verificar antes se a lista dos indices de métodos tratadores no retorno do método PontuacaoSequencia() está atualizada.---> verificado, os métodos BuildIndices e BuildEscopos estão recebendo a lista de indices corretamente.

	-----> o que falta:
		----> continuação dos testes para BuildEscopos().
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

--->  DailyScrum 07.06:
		---> implementado o extrator de propriedades OO, muito mais legivel e completo.

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

--->  DailyScrum 08.06:
		--->implementado o extrator de dados de classe, extrator de métodos de classe, extrator de propriedades de classe.	
		---> o método BuildAllEscopos foi removido, o método BuilAllSequenciasID() faz todas funcionalidades.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

--->  DailyScrum 09.06:
		---> precisa implementar o gerenciador de classes herdadas, modificando o nome longo de um método ou propriedade para conter o nome de classe (herdada ou não).
		---> início de testes de extratores OO.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

---> Daily Scrum 10.06:
	            ----> codificar uma classe que vincula o delegate TratadorDeSequenciasID(), com a string definidora da sequencia ID. feito.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
	    
---> Daily Scrum 13.06:
				----> testado o método de obter sequencias ID a partir do código, e dos tokens associados.
				----> fixado erro na classe ParserUniversal, havia o caso de IDs processados como um só.

				----> teminado a codificação de PontuaçãoSequencias(), que obtém todas sequências ID de um código, e obtém os índices de métodos tratadores.
				----> refatorado o método BuildAllEscopos(), mais legível e mais fácil de manter.

				REFATORAÇÃO NÃO É TRABALHO DESNECESSÁRIO, AJUDA NA CONSTRUÇÃO DO DICIONÁRIO DOS CONCEITOS DO PROJETO, como ContextoEscopo, SequenciasID, etc...
				---> simplificação na maneira de declarar a sequencia ID mapeada.
_________________________________________________________________________________________________________________________________________________________________________________

SPRINT ESCOPOS POO PRORROGADO PARA MAIS 2 DIAS (sprint do projeto tem 2 semanas para terminar).

---> Daily Scrum 14.06:
	---> revisar as strings de definição de sequencias ID, parece que está faltando declarar metodos tratadores e uso de strings de definição.--> revisado, havia suas sequencias sem construir o método tratador e o texto de definição da sequencia ID resumida mapeada. ---> fixado.
	----> testes com PontuacaoSequencia(), sucedido para sequencias ID constantes,falha para sequencias ID variantes.
			----> testar o método PontuacaoSequencia() com sequencia ID com variantes (sequencias que mudam de tamanho conforme for escrita).

---> Daily Scrum 17.06:
	----> testes para PontuacaoSequenciasID() com sequencias ID variante, reconhece o índice principal, mas falha no índice variante. ---> verificar o método ExtraiIndicesMetodosVariantes().
		----> fixado o erro, havia um contador incorreto no método tratador de sequencias id variantes.. e na malha principal do PontuacaoSequencias(), quando havia uma desigualdade de tokens, a lista de indices tratadores variantes era limpa.. ---> fixado.

--->Daily Scrum 19.06:
	---> inicializar testes para consrução de escopos, ver se as registrações e validações de tipos na lista de ContextoEscopo.
	---> fixando o BuildAllScopos(), é muito importante, pois se usa não só na Estruturada, mas também na POO.

	---> BuildEscopos() está trabalhando apropriadamente, mas o escopo raiz, que dá acesso aos tipos da linguagem, não está sendo acessado. ---> fixado.
		-----> fixar a construção do escopo raiz. ---> fixado em teoria, aguardando testes.---> fixado parcialmente, uma segunda sequencia ID não é registrada.---> o indice do método está correto, mas o acesso é para outro método.---> fixado, o método estava indexado para outro método.---> falha no cálculo da sequenciaID original, há um espaço vazio num dos termos que não permite a verificação se é ID. ---> fixado, a lista de tokens originais não era a da entrada.
		-----> fixar o problema de acessor (public, private, protected) que está aparecendo para todas variáveis. ---> fixado, se for null, que é o caso de variáveis, não seta o acessor.---> fixado.

_________________________________________________________________________________________________________________________________________________________________________________

--->Daily Scrum 20.06:
		---> verificar a obteenção de tokens vazios, pode comprometer os cálculos de tokens. --> fácil.--> fixado, testado positivamente.
		---> modificar os métodos para inclusão de métodos no extratorOO de métodos, ou retira a parte de registra de métodos por acesso direto na construção de escopo, e a partir do escopo, retirar os métodos, sem precisar acessar duas vezes a extração (um da construção do escopo, e um da extração direta do extrator, com métodos tratadores indexados).---> complexidade mediana, é preciso alterar o código do extratorMetodosOO().----> fixado, aguardando testes para POO.
		---> verificar a definição de métodos tratadores, e respectivas definição de sequencias ID. ---> complexo.---> verificado.

		----> validar chamada de função com expressões como parâmetro de uma sequencia ID---> codificado, a verificar. 
				--->  Foi codificado a extração de expressões, na classe ProcessadorID,
				      modificar apenas os métodos tratadores de sequencias ID.---> mediano. (método: ProcessadorID.RegistraExpressao(). feito aguardando testes.
				---> implantado no ProcessadorID o registro de expressões para todo tipo de sequencia id que contém atribuição ou chamada de método ou função. ---> aguardando testes.
		
		----> testar mais tipos de  sequencias de ID com o BuildAllScopos. ---> complexo.---> quebra no método ExtraiIndicesMetodosVariantesPorPontuacao().-->fixado, indices, indice tratador constante ok, falha nos indices tratadores das sequencias com variantes não reconhecidas.---> fixado, indices metodos constantes e variantes feitos com sucesso.

        ----> verificar a construção de escopos em BuildAllScopos.--> fácil.

__________________________________________________________________________________________________________________________________________________________________________________
--->Daily Scrum 28.06:
	---> testar os tratadores de métodos com expressões. Fazer a verficação de expressões em  chamadas de função e chamadas de método. ---> codificado nas chamadas de função e método com parâmetro.
	---> fazer um teste de construir escopos, que verifica a construção de escopos aninhados e não aninhados.
		---> codificado o construtor de todos escopos, e teste para BuildUmEscopo() sucedido.
_____________________________________________________________________________________________________________________________________________________________________________________________________
	----> Entrega do Construtor De Escopos (BuildTodosEscopos()) adiada por mais uma semana.
	----> Sprint OO quase terminada, faltando o verificador de classes- pai, e classes herdeiras.
	_________________________________________________________________________________________________________________________________________________________________________________________________
	--->Daily Scrum 29.06:
		---> testar chamadas de função com expressões como parâmetro. Teste codificado, aguardando a chamada de função. testes feitos, falha na coloção da expressão em PosOrdem, testar expressões colocadas em pós-ordem. fixado, os operadores nativos da linguagem estavam com prioridade=0, e a pilha de operadores no método FindOperador() não encontrava valores para parenteses ( e ). 
			---> teste para parametros de função como expressões, teste sucessamente.
			---> falha na obtenção de tokens variantes, no  método ExtraiIndicesTratador().---> fixado, teste sucessamente.

		---> testar método  BuildTodosEscopos().

		---> fatoração de SequenciaID, contendo agora os valores de sequenciasVariantes.
			---> com definição de valores de sequenciasVariantes, pode-se calcular de uma forma mais legível as sequencias variantes dentro dos métodos tratadores.
			---> teste com definição com tipo e atribuição, com variantes, testado sucessamente.
_____________________________________________________________________________________________________________________________________________________________________________________________________

--->Daily Scrum 30.06:
	---> Testes:
		---> testar método  BuildTodosEscopos().
	---> Atividades:
		---> construir um código que obtém uma sequencia ID, apenas uma. ---> codificado,testado sucessamente.

		---> recodificar o BuildAllEscopos(): 1- para quando um token for um ID, calcula-se a sequencia.
												2- quando um token for um "{", constroi um novo escopo.
												3- quando um token for um "}", volta para o escopo-pai. se um token for "{"" constroi um escopo folha. --> testado para um escopo somente.
	   ---> testar o BuildAllEscopos() para mais de um escopo, aninhado ou não.---> testes feitos, escopos aninhados e não aninhados trabalhando adequadamente!
						---> construção de escopos ok, mas para voltar para o escopo raiz, sem ser o escopo da linguagem.
						--> sucedido parcialmente, a construção dos escopos está parcialmente sucedido, a chamada de função não está aparecendo na tabela de valores. --> fixado, o método BuildAllEscopos() está funcionando adequadamente!.

	 ---->testado as seguintes seuquencias id no método BuildAllEscopos(): 
			1- definição de variável;
			2- egistro de função com parâmetros e sem corpo;
			3- chamada a função com retorno e com parâmetros.

	 ---> TESTAR para sequencias id: 
			1- atribuição de variável com expressão, [ok].
			2- atribuição de propriedade com expressao [ok],
			3- registro de método com e sem corpo, 3.1-com [ok] e 3.2-sem parãmetros [ok],
			4- registro de função 4.1 [ok] - com parãmetros e 4.2- com corpo [ok]. 
			
			1 , 4.1 e 4.2---> teste para atribuição de variável com expressão, e função com parãmetros e com corpo, teste sucessamente.
			2, 3.1, 3.2, e 4.1---> testes, falha, há problema de determinação de escopo pai. testes feitos sucessamente, mas verficar a sequencia de escopos.

	---> o código de adicionar escopo falha, há confusão de escopos folhas, e escopos pai. fixado, testes feitos, falha com uma sequencia id {;}, que gera um indice inexistente de método tratador.	---> indeterminado a sequencia {;}---> fixado, o operador de fecha bloco tem que ser colocado numa sequencia a parte, pois não faz parte das definições de sequencias ID mapeadas.
	---> fixar o acrescimo de escopo-global adicionais, deletando esses escopos, do escopo currente do processador de ID. ---> fixado, o operador de bloco abre: {, em sequencias de função ou método com corpo, não estava sendo processado, colocou-se então no método BuildAllScopos(), o processamento de operadores bloco abre dentro de sequencias id.

	---> introduzido uma trava de segurança, ordenando decrescentemente por comprimento da sequencia ID e método tratador, falha na obtenção de sequencias ID.
			---> o problema está no reconhecimento de operador bloco fecha..., na obtenção de uma sequencia ID.
					---> fixado, falha nos testes, há inclusão de escopos globais, não há reconhecimento de uma propriedade, e não reconhecimento de todas métodos tratadores.
						---> o BuildAllEscopos() é operacional, executa sem falhas, há um problema somente: duplicação de escopo global.

						---> nova codificação para obter escopos dentro das funções e métodos. ---> falha testes, há erros na obtenção do primeiro parâmetro de funções e métodos, os índices estão errados.


						---> O PROBLEMA DOS ESCOPOS É QUE ESTÁ CONTABILIZANDO NO MÉTODO BUILLALLESCOPOS() OS OPERADORES BLOCO PERTENCENTES A DEFINIÇÕES DE FUNÇÕES E MÉTODOS.
								---> a fixar, mas a construção de sequencias id no método ObterSequencia está correto, não há mais uma sequencia para um operador de bloco fecha...

	---> codificado um novo método para encontrar indices de métodos tratadores,  MatchSequenciasMapeadas(), mais legível, menos sujeito a erros. testes feitos, com uma sequencia de id complexa, com tokens variantes, feitos sucessamente.
						
	---> com o novo método para encontrar indices de métodos tratadores, e sequencias de tokens variantes, é modificado o algoritmo de  BuildAllEscopos().
		----> ESSA MARAVILHA DE ALGORITMO FOI FEITO GRAÇAS A COMPREENSÃO E MANIPULAÇÃO DO DICIONÁRIO DO PROBLEMA DE SEQUENCIAS ID, COMEÇANDO COM O CONCEITO DE SEQUENCIAS ID, E TOKENS RESUMIDOS.

	--->novos testes, falha para um método com 2 parâmetros, e corpo, falha, até porque o processamento do corpo do método não devia ser analizado numa sequencia, pelo método MatchSequenciaID().							
					---> verificando o método de obtenção de produções, falha para o método GetProducoes(), que é uma versão antiga, que, veja bem, não processa sequencias id!!! Apenas produções com termos-chave eram encontrados as produções.
_______________________________________________________________________________________________________________________________________________________________________________________________________

--->Daily Scrum 03.07:
	---> fixar o método GetProducoes(). (método GetProducoesPorPontos()). Codificado um novo método de GetProducoes(), que calcula também sequencias ID. modificações: classs UmaSequenciaID é herdeira da classe producao. aguardando testes;
	---> fixar o método de obter indices de método tratadores MatchSequenciaID(), para um método com 2 parâmetros e corpo. fixado (os operadores de bloco estão dentro do método tratador, e chama o BuilAllEscopos nos tokens do bloco), aguardando testes.


	---> faltando:
          ----> teste obter produções. Tokend.GetProducao(); teste feito, falha ao reconhecer a produção [for], descoberta: há termos-chave que são termos de sequencias ID, e não podem ser retirados!
				---> fixado, o algoritmo GetProducoes() trabalha adequadamente, mas a ordenação das produções não está trabalhando adequadamente.---> fixado, mas falha em duplicação de produção BLOCO.
				---> fixado, havia uma produção que a rigor, era inútil ([BLOCO]= [COMANDO]; ), sendo utilizada em obter produções por uma maquina automâto finito. --> testado, resultado positivamente.
		  ----> teste MatchSequenciaID(), para métodos com 2 parâmetros e com corpo.
					--> pronto para teste de MatchSequenciaID(). testes, cálculo de sequencias ID sucessamente, para definição de variável, e definição e atribuição de expressão, calculada sucessamente.
					--> pronto para teste de MatchSequenciaID() para definições de função com parâmetros e com corpo. ---> testes, falha na obtenção de métodos tratadores,e registro de função.


	---> foi constatado uma inconcistência na classe ParserUniversal(), faltando codificar os termos-chave presentes.--> fixadom, classe ParserUniversal comporta agora idsPresentes, operadoresPresentes, termosChavePresentes.
				--> a conferir se a quantidade de tokens termosChavePresentes, operadoresPresentes, idsPresentes de mesmo nome precisam se repetir ou não.
					---> uso de uma função que determina o se o caracter seguinte a um token é uma letra, pode-se firmar mais robustamente se palavras unida comom uma seja distinguivel.
								--> operandos ids[] presentes calculados corretamente, operadores[] presentes calculados também, falta os termoschave[] presentes.--> fixado.
										---> falta colocar os tokens na sequencia original correta.--> codificado, testes feitos com sucessamente.
		ParserUniversal fixado.

		--->GetTokens() operacional.
		--->GetProducoes() falha ante a mudança de escopo, no processamento de tokens de um bloco. 
			---> é preciso um novo método para determinar a posicao de tokens do bloco ante os tokens totais.---> codificado, aguardando testes. testes, falha no método ObtemMaiorIgualdadeDeConjuntoDeTokens().
			---> foi removido o caso de operador unário, é preciso codificar novamente.
		--->tabelaDeValores.RegistraExpressão modificada, para incluir chamadas de função como termo da função, expressões como parâmetros das chamadas de função da expressão.---> aguardando testes.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________

--->Daily Scrum 05.07:

---> testar o método BuildAllEsccopos(). ----> falha no tratamento de sequencias de funções, como funcaoA(); método ParserUniversal.GetTokens() está quebrado.--> fixado, o nome de operadores continham espaços vazios no começo ou fim do nome do operador.
				---> testes feitos, falha no método ObterSequenciasResumidas(), mapeia o operador [virgula], como OPERADOR.
				---> fixado, os tokens no ObterSequenciasResumidas() estavam com caracteres vazios no começo ou fim de sua string.
				---> testes, falha no reconhecimento de funções com dois parâmetros, e sem corpo.
				---> fixado, os textos de sequencia variantes foram ordenadas decrescentemente, mas falha na determinação de tokensAMapearResumidos e tokensMapeadosResumidos, pela falta de um indice de acrescimo ao indexToken em tokensMapeadosResumidos.
				---> fixado, teste para definição de função com dois parâmetros e sem corpo realizado sucessamente.


---> testar o método tabelaDeValores.RegistraExpressao(). --> testado para expressão B=1+5.

---> atividades fixadas:
		---> fixar e testar o método ObtemMaiorIgualdadeDeConjuntoDeTokens(). ---> fixado. ---> testando Tokens.GetProducoes(), falha de rompimento de indice de matriz de tokensBloco.----> fixado, mas parece que a ordem das produções esteja incorreto.--> investigando, há não retirada de operadores bloco, na lista [tokens], no método GetProducoes().--> fixado, havia problema de referência entre processamento de métodos, modificando a lista de tokens do método GetProducoes().
		---> se precisar, codificar o caso de operador unário, no método Tokens.GetProducoes(). ---> verificado, com avaliação de SequenciasID inclui sequencias de operadores unário.
		---> falha ao calcular o posicionamento das produções no método GetProducoes();--> fixado, não há necessidade de ordenar as producoes,
		---> falha ao calcular um bloco no meio de uma sequencia ID. --> fixado, testes, falha na sequencia que não tem ponto e virgula, mas após vem o operador bloco abre,
				OU após o operador parenteses fecha, que não está sendo computada na remoção de tokens de produção.--> fixado, testes trabalha adequadamente.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 07.07:

---> os métodos da classe PosicaoECodigo não estão trabalhando adequadamente, e são crusciais nos registros de erros. --> aparentemente fixado, retirada de caracteres vazios, mas nem todos método foram testados.
			---> métodos não testados:
				---> PosicaoECodigo(int qtdTokensParaPosicionamento, List<string> tokensPosicionamento, UmaGramaticaComputacional lingugem, List<string> programaTotal) ---> testado sucessamente;
				---> PosicaoECodigo(List<string> tokensPosicionamento, UmaGramaticaComputacional lingugem, List<string>programaTotal)  ----> testado sucessamente.
						---> textado, melhorado a mostra de texto em ToString()., melhorado os tokens que entram no trecho de codigo do objeto.


---> método BuildAllEscopos(), ajuste fino.
		---->testado para: "int C=1+3; int funcaoA(int A,int B ){int a=1;}", sucessamente."

		---> testado para: "int funcaoA(int B , int C);", sucessamente."

		---> testado para: "public int funcaoSemParamsComCorpo(){int a=1;} 
							public int C=1+3;
							public int funcaoComParamsSemCorpo(int A);
							public int funcaoSemParamsSemCorpo();
							public int funcaoComParamsComCorpo(int A,int B ){int a=1;}
									---> falha ao obter sequencias id, o operador bloco fecha não encerra uma sequenciaID.
												---> em método ObterUmaSequenciaID().---> modificado, aguardando testes para obter sequencias id
	 ----> reformulado os métodos ObterUmaSequenciaID(), e ObterSequenciasID().
	 ----> aguardando testes. testes feitos, aparentemente o problema de obter sequencias foi resolvido, mas os tokens de entrada estava separado por sequencias.
						----> testes feitos, com tokens do código, mas não achou todas as sequencias, apenas a primeira sequencia.--> codificação simplificando o método ObtemSequenciaID().
						---> fixado, testes, falha na última sequencia id. falha na contagem de operadores bloco.
						---> modificado o método ObtemUmaSequenciaID, pois pode haver sequencias id dentro de sequencias id.
						---> fixado, testes, obtido todas sequencias id de entrada, mas as que são blocos estão em uma sequencia id a parte.

						----> O QUE PODE SE DISCUTIR É SE AS SEQUENCIAS BLOCO DEVEM SER ENCAIXADAS NA SEQUENCIA ID ANTERIOR.




________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 10.07:

			----> continuar onde estava parado no método BuildAllEscops().
				---> sequencias id calculadas corretamente, prosseguir com testes para várias sequências ID.

				---> testes, falha para uma sequencia ID definicao de funcao, com parâmetros e com corpo. não está sendo calculado apropriadamente correto. mas os tokens variantes está sendo calculado apropriadamente.---> fixado o erro de indice de começo de tokens variantes, para a sequencia testada.
					----> fixado, mas a sequência variante e a sequencia constante não está sendo calculado adequadamente.---> fixado, testes sucessamente 
					----> fixado os casos de sequencia terminadas com ponto e vírgula, e terminada em operador bloco fecha, distinguindo de terminadas com operador bloco fecha, mas token anterior o operador parênteses fecha .

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 11.07:
			----> continuar os testes para o método BuildAllEscopos().
					---> teste para testeCalcVariosEscopos3()---> teses, quebra do código para função com parâmetro sem corpo.---> o método tratador está em função com parãmetros com corpo, e a função da sequencia é com parâmetro e sem corpo.
															 ---> fixado, o código para função com parâmetros sem corpo tem mesmo comprimento de função com parâmetros com corpo.
															 ---> foi encontrado um erro na lógica do código, mas que corrigiu-se na maneira que a malha de processamento de tokens foi construída.
															 ----> é de se chamar a atenção ao descuido da parte lógica dos algoritmos. Por exemplo, a falha do erro de lógica descrito acima, foi encoberto devido um if extra que não processava tokens<>tokenVariante, e esse if era desnecessário..
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 13.07:

	  ---->continuando testes em BuildAllEsopos(), falha ao não regitrar a definição de função: public int funcaoComParamsComCorpo(int A,int B ){int a=1;}, a última sequencia do testes.
					------> falha também não processamento de corpo da função. ---> tentativa de fixa, aguardando testes. fixado, testes sucessamente.
				
			
					-----> modificar o método de inicialização de função, para comportar acessors.---> feito, modificação na classe Funcao, e nos método tratadores.
					-----> retirado vários erros de definição de função e definição de método, com corpo de função/método.

	O QUE FALTA:					
	------> falha também em geração de escopos desnecessários. (parece vazamento de referência).---> parcialmente fixado, obtém os escopos em sequencia correta, mas não registra os objetos da tabela.---> fixado, aguardando testes.
	------> falha ao não regitrar a definição de função: public int funcaoComParamsComCorpo(int A,int B ){int a=1;}, o problema está no método MatchSequencia().--> fixado o indice de método tratador principal, mas a sequencia de variantes não está sendo calculada.

	________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
	---> Daily Scrum 14.07:
		----> os métodos tratadores foram refatorados, com partes em comuns dividida em um método para esta parte.

		----> verificar a correta avaliação de escopos.
		----> implementar a avaliação de expressões, como parâmetros de chamada de uma função. ---> codificado na tabela de valores, método RegistraExpressao()

		----> fixar o problema de obtenção de métodos tratadores para tokens variantes, no método MatchSequencia(). ---> não foi constado erro fatal na busca de indices de métodos tratadores, mas o problema dos escopos continuam.
				---> por motivos de modificar código em uma só parte em vez de modificar várias partes do processador id, foi refatorado o código e extraído partes em comum a todas sequencias mapeadas.
				--->sequencias mais básicas, como "ID ID;", não estão sendo avaliadas. fixado para obter indices de sequencias mais básicas, o que funcionou ja que o indice tratador é um das ultimas sequencias ja mapeadas.
				---> o codigo do método MatchSequencias() está quebrado na determinação de indices variantes. ---> retrabalho para codificar um algoritmo de busca de tokens variantes;
				---> testes feitos com um novo algoritmo de busca de tokens variantes, com sucessamente. 
				---> ao que se percebe, o algoritmo do método MatchSequencias() está sem quebra, segue novos testes.

       		----> verificar a construção de escopos na mesma sequencia que foi utilizado no teste sucedido para o método MatchSequencias().---> verificado, construção de escopos foi bem construida, para o teste de MatchSequencias() com declaração de função com dois parâmetros e sem corpo.
				----> verificar a correta avaliação de escopos.----> para o teste mencionado, a avaliação de construção e avaliações de escopos foi feito corretamente, inclusive a construção de escopo pai, e escopos folhas.
				
				************************************************************************************************************************************************************************************************************************************************************************************************
       		1----> o que falta para finalizar os métodos de ProcessadorID:

				1.1----> testar o método TabelaDeValores.RegistraExpressao().---> o código estava dificil legibilidade, foi recodificado para ser mais simples. ----> aguardando testes.

				1.2----> seguem os testes para BuildAllEscopos(). 
							----> testes para definição de variável sem atribuição, chamada a função com mais de 1 parâmetro, definição de função com mais de um parâmetro sem corpo, testes feitos sucessamente.
										----> os indices de métodos tratadores para a parte constante de uma sequencia ID calculados sucessamente. tokens variantes tb calculados sucessamente.
		       							----> faltam testes para funções com corpo.  testes bem sucedidos! para uma sequencia de definição de função com parâmetros e com corpo, registrando também as sequencias id do bloco, corpo da função.

							---> testes para 6 tipos de sequencias id, para o método BuildAllEscopos().		
											----> testes com 6 sequencias, falha na construção do escopo do corpo da função, deveria estar num escopo folha, mas estão no escopo normal principal.
											----> todas sequencias tiveram seus indices tratadores constantes e variantes calculados corretamente, e o escopo do corpo da função está registrado no escopo raiz do ProcessadorID.
															---->falha em vazamento de referências na construção de escopos de corpo de função. os escopos até são construidos, mas estão vazios. investigando o método BuildAllEscopos().
															----> fixar o vazamento de referências em Escopo.AddEscopo(escopoFolha, escopoRaiz);
															---->HAVIA UMA REFERENCIA AO ESCOPO INICIAL DA CLASSE PROCESSADOR ID, E QUE ESTAVA SENDO UTILIZADO COMO PARÂMETRO DE BUILDALLESCOPOS(), QUANDO O PRÓPRIO PARAMETRO É QUE DEVERIA SER UTILIZADO DENTRO DO MÉTODO.
																----> OUTRO FATO É QUE HOUVE UM CÓDIGO CONFUSO PARA SE PASSAR DE UM ESCOPO PARA OUTRO, QUE FOI REMOVIDO, UMA LIGAÇÃO DE ESCOPO-RAIZ E ESCOPO-FOLHA.---> fixado, ufa.......


			2----> o que falta para finalizar os métodos de ProcessadorID:
					--->testar o método TabelaDeValores.RegistraExpressao().
							---> o código estava dificil legibilidade, foi recodificado para ser mais simples. ----> testes, fixado, o operador para aumentar a prioridade poderia ser um não operador, o que gerava um operador nulo tentando obter prioridade.
							---> o método RegistraExpressão está operando adequadamente. Uma possível alteração seria refatorar o método PosOrdem Expressão, não está de boa legibilidade, e a regra de negócio para distinguir operandos binários de operandos unários, em casos como + (+1, exemplo), ou - (-1, exemplo).

		   3---->os métodos de ProcessadorID estão fixados!, Pode-se encerrar a Sprint Funcionalidades OO, pois o método BuildAllEscopos() está operando adequadamente.

		   -----> Sprint Backlog cumprida, segue a Scrum Review, para verificar o que foi bem executado, o que poderia melhorar. Sprint entregue com ~3 Semanas de Atraso, mas a próxima Sprint já havia iniciado, por fatores de stress sob pressão de código trabalhando adequadamente.

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 15.07:

		---> incremento de funcionalidade, acréscimo de chamadas de função na avaliação de expressões.

				----> codificar a obtenção de funções termos-expressão, dentro da lista de termos-chave
				      da expressão a ser avaliada ou colocada em pos-ordem. ----> implementado. Os termos-expressão de uma chamada está colocado em pos-ordem.
					  (a expressão em pós-ordem facilita a avaliação de expressões).

				---> codificar a inserção de funções termo-expressão, na expressão a ser colocada em pós-ordem.	Nada de árvores-de expressão, o cálculo é direto e simples, com uma pilha para conter os operadores e os operandos.	Inserção de função como termo-chave implementada,
				falta codificar a colocação ou remoção de termos-expressão da função-chamada, dentro da expressão a ser avaliada em pos-ordem. --->codificado, a testar.
					---> testes, falha na inclusão dos nomes dos operadores, na expressão. fixado, expressões aparentemente estão sendo colocadas em pós-ordem.


		---> verificar as prioridades dos operadores. uma polêmica é se o operador de atribuição = entraria na avaliação Pos-Ordem. verificado.							
	
	    ---> codificar o teste para verificação de expressões com chamada de função como termo de expressão. codificado.
					---> testes, falha justamente na sequencia de expressão com chamadas de função. O erro está na determinação do indice tratador constante. Com o indice errado, o acesso com a construção de escopo é incorreto.
					---> fixado, se  (indice de token e tamanho da sequencia mapeada)>1, efetua o teste de tokens mapeados e tokens a mapear. ---> testes, sucessamente, mas a fixação do código para teste de tokens talvez não seja correto para outras sequencias id.
							--->logicamente, o último token geralmente é um ponto e vírgula, vindo da construção de sequencias id, não entram na combinação de sequencias mapeadas.
							--->falha para outras sequencias, volta para o teste de indice da malha== comprimento dos tokensJaMapeadosResumidos.	

		---> bateria de testes, falha para [public int funcaoComParamsComCorpo(int A,int B ){int a=1;}] que está sendo no escopo como variável e não definição de função.
								----> escopos folhas, no mesmo teste, não está aparecendo, no caso de corpo de função existente.
								----> fixado, houve erro no cálculo do ponto de inserção da sequencia variante, no caso do codigo de teste mencionado.
								----> indice tratador = 8 para a sequencia acima sob teste. ---> verificado, é o indice de metodo tratador para o teste mencionado.

		---> testes, escopos-folha calculados corretamente, com corpo de função calculados corretamente, mas o número de diferentes funções na tabela de valores está inconcistente.
			 São 4 funções, foi registrado apenas 3 funções. sequencia de propriedade do teste mencionado calculado corretamente.

	   ---> RECOMENDA-SE MAIOR ATENÇÃO NOS CÁLCULOS QUE NÃO SÃO VALIDADOS NA COMPILAÇÃO, COMO VALIDAÇÕES EXPRESSAS EM STRINGS, EM VEZ DE ENUMS.

	   O que falta para os testes de registro de expressões:
			----> cálculo correto para as sequencias id do arquivo de texto [codigo1.txt]. São quatro funções registradas como valores esperados, e não 3 funções registradas como valores calculados.
						---> testes feitos para a sequencia id calculada incorreto, eliminou-se o caso de [;], e retorno do método se o indice da malha de tokens igual ao comprimento da sequencia mapeada resumida.
	  --->no método MatchSequencias(), o melhor resultado é um boolenao isAchou para capturar casos que houve quebra de indices na malha, seguido do teste que verifica se o indice de tokens=comprimento do vetor de sequecia ja mapeada resumida.
	  --->fixado, testes feitos para cinco sequencias, com calculos sucessamente. Calculos para registro de expressõe comporta por números ou variaveis, testes sucessamente.

*******************************************************************************************************************************************************************************************
---> Daily Scrum 16.07:

	  ---> testes para a nova funcionalidade: uso de funções no cálculo de expressões.
				---> modificado o método MatchSequencias() para verificar se um token é nome de função, e eliminar a lista de tokens da chamada da função, para o cálculo do indice tratador.
						---> codificado um método que substui a chamada de função pelo nome da função, para processamento de sequencias ID.
							testes com novo método de substiuição, falha em seqeuencia de ids com funções como termos de ezpressão. substituição de termos de expressão,
							o teste passa, mas para sequencias como: int a= 1+4;

	----> verificar o indice de inserçao para sequencia id: ID ID= ID; fixado, a sequencia variante estava setado com a sequencia de dentro do algoritmo, e não da entrada...---> testes sucessamente.
	----> testes para ID ID= ID OP OP ID (exemplo: int a= 1+5+5), teste sucessamente.
	----> funcionalidade de funções no cálculo de expressões entregue, com 2 testes de sequencia com funções como parâmetros.
				----> mas... está registrando erro de tipo de expressão incompatível da função parâmetro, verificar RegistrarExpressao(). 
					  verificar construtor Expressao(), está registrando erro de tipo incompativel de expressão.  fixado, tipos de números para identificação de tipo da expressão: int e float.

	---> fixado erros para todos testes, prosseguindo com a Sprint Funcionalidades POO.
___________________________________________________________________________________________________________________________________________________________________________________________

---> Daily Scrum 18.07:
	----> inicio da Sprint funcionalidades POO.

	----> testar o extrator de métodos e o extrator de propriedades. testes, fixado, testes sucessamente.

	----> planejar o uso de interfaces OO. codifica o método que averigua se a classe implementou uma interface.

	codificado a validação de classes herdadas e interfaces, apenas os nomes das
	      classes e interfaces são calculadas, falta o acréscimo dos métodos e propriedades e interfaces na classe currente.
				----> é preciso o planejamento do local (repositório) das classes de um Projeto Orquidea OO.  ---> codificado, 
					com o padrão singleton para o Repositorio, garantindo a centralização em  um único local dos registros da classe.

	----> planejar a funcionalidade de herança, herdar e deserdar classes.
			---> codificado o método de compor métodos e propriedades de classes herdadas.
			---> codificado método de validação de implementação de interfaces.

	  //	O QUE É DE SE ANOTAR É QUE AS INTERFACES NESTA LINGUAGEM TEM PROPRIEDADES TAMBÉM, E QUE DEVEM SER IMPLEMENTADAS NA CLASSE HERDADA.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
---> Daily Scrum 20.07:

		---> codificado a extração de classes e interfaces herdadas, aguardando testes.
		---> codificado a extração de classes e interfaces deserdas. ---> codificado, o extratorOO processa corretamente o código, mas está extraindo apenas 1 classe e o código do teste tem 2 classes.
				---> codificado método para obter várias classes, com herança e deserança.

		problemas do dia:
		---> dificuldade de calcular o código da classe, o nome da classe está junto com o operador : declarador de herança. ---> fixado, há um erro na obtenção de tokens, o nome da classe e o operador de abertura da herança da classe ficam juntos. fixado, aguardando testes.
					---> testes, falha na obtenção de métodos na classe que tem herança, no teste. O problema é o escopo, sua construção com tokens da classe. fixado.
					---> ainda não codificado a inclusão das classes herdadas no objeto classe criada.

		---> codificado métodos de acrescentar herança, métodos de retirar herança.
		---> codificado método de inclusão de métodos e propriedades de classes herdadas.

		--->teste extrator de classes bem sucedido.


		--->criar métodos Save/Load para classes em tokens.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.08:
 
	---> testes  método ConstroiClasses(), ConstroiClasse(), feitos sucessamente.
	---> codificado a validação de interfaces.
	---> a codificar o método Load() para a classe Classe.
			--> codificado um método Load() e um método Save() para tokens da classe. Com os tokens, é possível construir novamente a classe a partir da classe ExtratoresOO.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.08:
    ---> testes no extratror de classes, falha na obtenção de herança.
        ---> fixado, testes sucessamente.
    --> método ConstroiClasse() testado com sucessamente!
    --> método extraiClasses(), extraiMetodos() e extraiPropriedades, testados sucessamente!
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.08:
	---> testar os métodos Save/Load da classe Classe. Métodos Save/Load funcionando adequadamente!

	---> testar a construção/validação de interfaces. falha, modificação de código quebrou o código.
			---> falha na extração de propriedades. investigação, o processador de sequencias id não reconhece os operadores de herança + e - para classes.
					---> fixar, incluindo sequencias id para definição de classes. fixado, havia um erro no extrator de propriedades na classe ExtratoresOO, o código deveria ser dentro da classe currente, não o código total a ser analisado. testes sucessamente.


	---> continuando a testar a validação de interfaces. testes, registra a classe, e registra um erro de classe ou interface herdeira não registrada. a verificar...
			---> o código de código da classe está quebrado, não está registrando os operadores de herança e deseherança.
				---> método quebrado: GetTokens()! ---> classe ParserUniversal. fixado, tinha que adicionar um espaço em branco para extrair operadores presentes. 
												   ---> outra possível falha é nome de operadores contiverem nomes de termos-chave, caso já previsto, mas não implementado na última versão. fixado.	


				---> detectado uma falha em Parser Universal: tokens com nome contendo palavras-chave não estão sendo reconhecidos como operadores.. fixado.
	---> continuando testes com validação de interfaces. testes, não gerou mensagens de erros para classes com herança, mas lista de classes de heranças é null. fixado.
				---> verificando método ValidaInterface(). retrabalho no desenvolvimento do código, codificado novamente o método ValidaInterface().
				---> testado, para o caso de não implementado a interface na classe herdeira, resultado sucessamente.

	---> o que falta: (feito)
		---> teste para o caso de implementado a interface na classe herdeira. ficado, testes, resultados sucessamente!

		--> incluir na herança e deserança os operadores da classe.(implementado), talvez tenha que se testar.
		--> incluir no RepositorioDeClasses, as classes nativas da linguagem orquidea.(implementado.)

	---> fazer um teste para herança e deserança de operadores, em uma classe a ser construída. (implementado).

				---> incluir nos termos-chave da linguagem a palavra: operador.
					---> adicionado a producao operador (OPERADOR BINARIO), com sequencia ID: "operador ID ID ( ID ID , ID ID)", sem variântes. (feito)
					---> adicionando a sequencia id  no Processador ID, para a definição de "operador ID ID ( ID ID , ID ID)". (feito)

				---> codificado o teste para processamento de sequencia ID de uma definição de operador.
						--> recodificado o método de obter sequencias id resumidas, para incluir termos-chave na sequencia resumida,
							e retirar caracteres de resumo, pois os termos-chave inclui estes caracteres.

				---> testes parados no método MatchSequencias(). teste para sequencia definição operador.fixado.
				teste para sequencia id de operador sucessamente concluido!
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.08:

	---> PENDENCIAS PARA AJUSTE FINO DA SPRINT PROGRAMAÇÃO ORIENTADA A OBJETOS.

			---> verificar o problema de sequencia de id para chamada a propriedades e chamada a métodos, com utilização de ".objeto1.objeto2.propriedade1", "objeto1.objeto2.metodo1()", atualizando a sequencia variante .ID, que já está feita, mas não utilizada.

			---> acréscimo de funcionalidade: implementar uma sequencia de operador unário: "operador ID ID (ID ID) prioridade ID;", acrescentado um método tratador para operador unário, nos moldes de operador binário, já implementado. feito, teste codificado, aguardando aplicação do teste.
						---> testes feitos, funcionalidade de operador unário operacional!

		    --> para o problema de chamada de propriedades ou métodos, modificar os métodos tratadores:
					---> ChamadaAMetodoComParametro.
					---> ChamadaAMetodoSemParametro. (feito)
					---> AtribuicaoPropriedade

					para incluir chamadas múltiplas de propriedades ou métodos, como:  A.B.C=1, A.B.c().

	---> o que falta e qual o impedimento do dia:

				---> terminar o método ChamadaAMetodoComParametro(), o cálculo das expressões.(feito)
				---> codificar o método AtribuicaoPropriedade. (feito)

				---> PARA O CÁLCULO DAS EXPRESSÕES, VERIFICAR O MÉTODO:  validaExpressao(sequenciaEntrada, escopo) na classe ProcessadorDeIDs.
									---> método validaExpressao() modificado, para validar expressões em AtribuicaoPropriedade().

				--->é preciso um método que obtém parâmetros de chamada de função ou método, com multiplas expressões.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 06.08:

			---> falha no método ObtemUmaSequenciaID, não reconhece a palavra-chave [class].
					---> fixado, estava retornando a sequencia de um bloco, mas devia retornar todos tokens de retorno.

			---> falha: palavras-chave como class o operador aparecem na sequencia resumida, tendo quebrado o método MatchSequencias().
						   A palavra chave operador tem uma sequencia id definida,
						   mas a palavra chave class não tem uma sequencia id definida.

						   --> fixado: reconhece classes, mas..
						   ---> a classe ExtratoresOO não valida atribuição de propriedades..


			---> fixar a atribuição de propriedades na classe ExtratoresOO.
						---> é preciso tratar definições de métodos e propriedades no método BuildAllScopos, logo depois de fazer o processamento de clases.
						---> solução encontrada:
								---> modificado o código de BuildAllEscopos(), para compor classes e constuir o escopo do corpo das classes.
						                    --> fixado, primeiro teste, para o escopo de uma classe somente, feito sucessamente.
											-->  essa modificação é até que lógica, pois todo código da linguagem OO Orquidea é feito dentro de classes.


			---> prossegindo o teste para atribuição de propriedade, que foi o incremento de propriedade que gerou estes testes.

					---> testes parcialmente sucessamente, construção de escopos para cada classe ok,
						 registro de propriedades ok, mas não reconhece os tipos de outras classes do teste.
						 fixado, as classes são registradas automaticamente também no escopoRaiz, que é o Escopo Global.


					---> falta o teste para atribuição de propriedade, no método tratador de propriedades, onde pode haver multiplas chamadas de objetos para composição da atribuição.
					---> as expressões de atribuição de propriedade estão sendo registradas, mas para validar uma expressão
						 é preciso verificar as classes dos termos da expressão.

					---> para concluir, é preciso um teste que falhe, que gere uma mensagem de erro na composição da expressão.
								--->método RegisraExpressao() não trata de objetos, nem com chamadas de objeto.
										---> é preciso validar as propriedades chamadas com o objeto inicial.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 08.08:

		---> codificado um método mais abrangente para obter expressões, na classe TabelaDeValores.ObtemExpressao.
						--> faltando a validação de operadores, se tem na mesma classe do tipo da expressão.

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 10.08: (continua a Sprint funcionalidades OO, refinamento).
		---> método RegistraExpressao() funcionando corretamente!
		---> método ObtemExpressao() funcionando sem erros fatais, mas não processamente propriedades encadeadas.
		---> falta codificar no método ObtemExpressoes, a validação de propriedades encadeadas das classes respectivas.
					--> codificado, testes, falha na obtenção de obter propriedades encadeadas.

		---> métodos em testes: ---> TabelaDeValores.RegistraExpressao().
								---> TabelaDeValores.ObtemExpressao().
								método principal: TabelaDeValores.ObtemExpressao().

		FALTOU UM PEQUENO DETALHE DE IMPLEMENTAÇÃO: EM QUAL PARTE DO CÓDIGO ESTÁ A EXPRESSÃO?
				---> Além, os dois métodos de registrar expressão são redundantes, apenas um método basta...
		--> a classe Expressão precisa ter um campo inteiro, que identifica a expressão entre as sequencias id. --> implementado, o nome da sequencia id que contém a expressão será o id.
	
		--> testes com TabelaDeValores.ObtemExpressao(),
				faltando validar chamadas por objetos, propriedades ou métodos, no meio da expressão.
				codificado parcialmente, falta obter mais de uma propriedade aninhadas.


				
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 11.08:
---> completado o código de TabelaDeValores.ObtemExpressao(), com reconhecimento de 
				propriedades/métodos aninhados, 
				nomes de variáveis, nomes de funções, chamadas de funções, nome de classes, nome de objetos.
---> teste para expressão simples, com variáveis registradas formando a expressão, testado sucessamente.
---> teste para expressão com propriedades, falha, não obtem o tipo da expressão. O escopo não está registrado as classes.
				----> ObtemExpressao(), o escopo não está registrando as variáveis. Por que os escopos de classe estão aninhados independentemente, em escopos separados!!
								----> é preciso identificar variáveis, sem utilizar o escopo currente.
										---> fixado, codificado um método que valida nome de classe, nome de propriedade, nome de método, com o token currente.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 12.8:

---> teste para expressão com chamadas de métodos. falha, método tratador de sequencias id para funções sem parâmetros sem corpo não está sendo acionado.
			--> quebra, pois a sequencia id "ID ID = ID ( ) " não está mapeada.
			--> uma solução é calcular para cada id como se fosse uma expressão,  retirar os tokens da expressão e substituir por um [ID], para o cálculo do MatchSequencias() funcionar para todas sequencias id que contém expressões.
			--> codificado um método ExtratorDeExpressao(), para calcular os tokens de uma expressão, para o método MatchSequencia(). testes, sem erros aparentes.
					---> teste para definição de ID com ExtratorDeExpressao(), como "ID ID ;", feito bem sucedido!
			--> teste para definição de propriedades, com atribuição de expressão com métodos e propriedades, como o caso da sequencia "ID ID = ID ( )".

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 13.08:
			--> teste com expressão com variáveis e funções resultou em um não registro de expressão.
					--> falha provável está no método ExtraiExpessao(), dentro do método MatchSequencias().
					--> fixado, com a introdução de um novo resumo, "EXPRESS", para processamento de resumo de ids.
					--> teste para chamadas de funções, resumo de variáveis inicializadas com atribuição, realizado bem sucedido!

			---> quase, falta obter expressões como funcaoA(), em uma expressão como int x=1+funcaoA(), não retire os parênteses no processamento da expressão.
										--> modificar o método ExtraiExpressao(), para conter um retorno após uma funcaoA() for realizada.
										--> o método que precisa ser codificado é o tratador de sequencias, pois o método MatchSequencias() está operacional.
										--> verificado o método tratador de sequências, o bug está no registrador de expressão, TabelaDeValores.RegistraExpressao().
										--> fixado, o nome da função, o primeiro parênteses e o último parênteses não estavam sendo registrados no ObtemChamadaDeFuncao(), que é chamado por TabelaDeValores.RegistraExpressao().

			---> codificação com item "EXPRESS" operacional!
			---> tratamento de sequencias id como "ID ID = ID ( )", problema encontrado em DailyScrum 12.08, solucionado!.

			---> funcionalidade perdida para colocar uma [Expressao] em PosOrdem, recolocada nesta classe.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.09:
		---> grande "sacada": para cada sequencia id, pode receber expressões contidos dentro da sequencia id, o que permite extender os tipos de sequencias id para instruções da linguagem, como "while[expressao]{".

		---> inicio da construção de métodos para tratamento para sequencias id de instruções da linguagem, como "while", "for", "if".

		---> construção da sequencia ID de uma produção,
		              testar o método ObtemTokensDeUmaProducao(). A sequencia Id traduzida em uma sequencia id é cruscial para obter métodos tratadores.
					  ---> iniciado testes, sem erros fatais.
					  ---> terminado testes, sucessamente. Tokens de Produção determinada com precisão, para uma sequencia id.
					  ---> acréscimos de excludentes de tokens, para operador, id, e operador vírgula, formando o método ObtemTokensDeUmaProducao() além do teste inicial.

		---> incremento no método ObtemUmaSequenciaID(), para processamento de tokens de produções. Aguardando testes.

		---> teste do método ObtemUmaSequenciaID(), cruscial para processamentos de produções como sequencia ID.
						---->  ObtemUmSequenciaID() está óperacional!
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.09:

	    ---> com a utilização de produções da linguagem na obtenção de sequencias id, foi detectado um bug no método MatchSequencias(), com a nova funcionalidade a ser implantada.
								----> na obtenção de expressões dentro do método MatchSequencias(), o uso de ponto e vírgula é utilizado como finalização de expressões, mas também é um termo-chave!, ao retirarmos o ponto e vírgula, teremos uma falha
								ao tentar obter o token da sequencia mapeada, do ponto e vírgula como token da sequencia mapeada.

	   ----> inicio dos métodos tratadores para instruções da linguagem Orquidea.

					---> planejamento da instruções da linguagem transformada para instruções VM.
					---> codificado método tratador para instrução while().
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.09:

	  ---->(feito, aguardando testes), novo algoritmo para obter produções: gerar os tokens, obter os tokens resumidos, eliminar as expressões dos tokens, e fazer a comparação de termos-chave da produção com os tokens!!! É um método mais simples e claro para se manter.(feito, aguardando testes. Algoritmo menor e mais compacto que o método GetProducao() atual.
	  ---> fixar o problema de encontrar expressões em MatchSequencias, e com sequencia mapeada com ponto e vírgula, que tabém é avaliado como token de uma expressão.


	    ----> pausa para métodos tratadores de instruções de linguagem, para codificar a classificação de tipos de expressões, validação para operadores binários, unários.
					
					---> validação de termos para operadores binário, unário. (feito, método Expressao.ValidaPosicaoOperando())


					---> conversão de operandos, se possível, com casting automático. (feito).
								---> casting entre tipos primitivos, e casting entre objetos de classes herdeiras.
							    ---> na classe expressoes, verificar se há métodos casting para conversão de termos. criado uma classe de conversores (casting).


					---> verificação de operadores condidionais.
					---> restrição: validação de operadores unario somente pos-ordem na ordem do parâmetro.


         ---> o que falta, além do bug no método MatchSequencias():

					---> verificação de operadores condicionais, binários aritiméticos, unários aritméticos.
								verificação de operadores binarios e unarios na inicializaçao de um objeto Expressao.
								---> Validação de operadores condicionais está na classe Expressao.
								---> Validação de operadores binarios aritmeticos na classe Expressao.
								---> VAlidação de operadores unarios aritmeticos na classe Expressao.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.09: 
																											
					---> testes para o novo método GetProducoes(). codificado o teste, pronto para rodar.
							---> os operandos das expressões precisam ser registradas, antes de chamar o construtor. fixado, as expressões de GetProducoes() fazem chamada de um construtor vazio, que apenas inicializa listas e propriedades default. falha, não se pode validar as variáveis da expressão, nem determinar o tipo de retorno da expressão.

							---> para simplificação do método, as expressões não são extraídas em GetProducoes().	

					---> método GetProducoes() versão beta, ainda em testes, mas a idéia de utilizar sequencias id resumidas é uma boa idéia, simplifica muito o procesamento de termos-chaves de uma produção.
								---> incluir as expressões dentro de GetProducoes() não é o melhor a ser feito, as expressões geradas são sem validação de tipos e nomes de variáveis.
								---> testes, método GetProducoes() falha, constroi duas produções de mesmo tipo como saída do método.
											----> construção com blocos está quase ok, não encontra produções dentro do bloco. tentativa de fixar o erro, foi incluindo na malha com termos-chave uma funcionalidade para processar blocos.
											----> tentativa de fixar o problema de produçoes de mesmo tipo como saída do método.
											----> tentativa de fixar o caso de uso para termos-chave ";", pois a contagem de termos-chave mais abrangente falha, ao excluir termos-chave ";" da sequencia de tokens resumida.

					---> continuar testes de GetProducoes().
								---> teste parcial, o método está obtendo producoes com termosChave como token.
									 falha nos demais testes, o método entra em loop infinito, com novas modificações no código.
									 fixados, está quase lá, faltando o processamento em bloco, e processamento de uma sequencia id.
									 falha na obtenção de uma sequencia de id, porque estava tentando registrar a expressão, sem que as variáveis e tipos de variáveis da expressão não estavamregistradas.
									 fixado, falha na obtenção de uma sequencia id, pois para acrescentar a funcionalidade de termos-chave dos tokens da sequencia, não verificou se o ponto-e-vírgula deveria ser contabilizado antes dos termos-chaves.


					---> uma anotação: produções dentro de produções não foram tratadas. Pode ser conseguido no  método ExtraiIDExpress(), que retira os IDs e Expressões, poderia retirar expressões e processar estas expressões em GetProducoes();
									----> codificar a extração e processamento de produções para expressões extraidas do método ExtraiIDExpress().
					
					---> testar a validação de operadores, aritméticos, condicionais, binários, unários. testes, fixado, acréscimo de um novo campo na classe Operador: tipoFuncao.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.09:

				----> codificado a extração de expressões dentro do método ExtraiIDsEOperadores(), aguardando testes.
				
				----> fixar o erro de obter operadores que são compostos por outros operadores, como == e ++, nos métodos GetTokens(), e ParserUniversal. fixado, na classe ParserUnivrsal, aguardando testes.
				
				----> fixar o erro de falsos termos-chave, que são palavras que contém um termo-chave no final da palavra ou começo da palavra. fixado, na classe ParserUniversal. Aguardando testes.

				o que falta:
						----> rodar o teste para obter tokens polêmicos.
						----> rodar o teste GetProducoes() da classe Tokens.

				----> UM INSIGHT: TODAS PRODUÇÕES DENTRO DE PRODUÇÕES SÃO EXPRESSÕES, POIS NA LINGUAGEM DE PROGRAMAÇÃO NÃO SE TEM PRODUÇÕES DENTRO DE PRODUÇÕES!!
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.09:
				---> teste para tokens polêmicos, falha, no cálculo do termo correto id, e remoção do termo incorreto na lista de termos-chave presentes.
							----> quase lá, falta a remoçao da parte do token, presente na lista de ids presentes, seja removido.

									---> fixado, mas falta outro caso de uso: "mfor", resultando em "m" ,"for" e não "mfor" (um id).
												---> codificado, o segundo caso de uso, aguardando testes.
												---> falha em reconhecer "form". fixado.
												---> quase lá, modificado o codigo para fixar, apareceu outro erro em outra parte do código.
												---> fixado, retirado os número como caracteres válidos, retirado o indice fini, testes, sucessamente.
												mas o termo de teste tem que ser também letra!.
									----> testes "int form=0;", sucessamente.
									----> testes com "int mfor=0", falha em encontrar os tokens corretos. fixado, mas há incerteza quanto ao comprimento do indice para formar o termoCorreto, somaddo +2, quando esperado era +1.
												---> reformulado a parte de idCorreto, mas permance uma estranheza quanto aos cálculos.
												---> refatorado, a posição do último termo deve ser incrementado em +1, para a posição válida de caracter válido, com isso, o cumprimento do texto é igual ao indice x da contagem de tokens com caracteres válidos..
												---> refatorado, para uma forma legível do algoritmo de extração do termoCorreto.
				---> testes para operadores polêmicos, sucessamente.


				---> incremento, caracteres válidos para id podem ser também números.
				---> reforado o segundo caso de uso, mais preciso, e mais racional e legível o algoritmo.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scum 15.09:
			----> continuando testes com método ParserUniversal= GetProducoes(), foi encontrada uma falha para composição de números, como 1 e 11, no método GetTokens(),
					----> tem que verificar se dois tokens são números em sequencia, então deve reunir os tokens, após ou antes da extração de tokens palavras-chave com defeito. fixado, com nova versão de GetTokens() na classe ParserUniversal. testes sucessamente.
					----> eliminação de tokens juntos, separados por um caracter vazio, codficado (verficação do código em RunTime). testes sucessamente.
					----> mantido no código GetTokens() o sub-algoritmo de corrigir IDs que tem letras que formam um termo-chave. testes sem tokens polêmicos sucessamente.
			
			
			---> continuando o testes com o método GetProducoes(), na classe Token.


		       ---> codificar métodos ObterTokensID(), ObterTokensOperadores(), e ObterTokensTermoChave(), que pode simplificar o método GetProduçoes(). PRIORITARIO.



_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scum 16.09:

			---> codificado e testado sucessamente métodos para obter TokensIDPresentes(), TokensTermosChavePresentes() e TokensOperadoresPresentes.

			---> testes para Tokens.GetProducoes().
							---> testes, quase lá, os termos-chaves estão obtidos corretamente, no ParserUniversal.GetTokens().
							---> fixado, os termos-chave estão sendo processados corretamente, mas a malha principal está com indices não atualizados.
							---> fixado, testes, método Tokens.GetProducoes() operacional!, faltando obter as expressões sub-producoes.
							---> tentativa de obter semi-produções, falha, há confusão dos indices da malha e indices das sequencias.


							---> semi-producoes obtidas!, falta ordenar as produções na ordem em que aparecem.


		   --->	proximo item do Sprint Backlog: 
					----> Codificação de processamento de sequencias id para instruções de linguagem, como "for", "while", "if".
							---> construido os textos de definição para instruções for, while, if.


		  ---> codificação para ordenar as produçoes encontradas no método GetProducoes().
						---> terminar o indice para ordenacao de producoes pela classe PosicaoECodigo.
						---> codificado, aguardando testes. testes sucessamente, fixado erros na classe PosicaoECodigo. Favor tomar mais atenção.


		  ---> método GetProducoes(), com produçoes, semi-producoes, sequencias, blocos, operacional!



				   --->	proximo item do Sprint Backlog: 
					----> Codificação de processamento de sequencias id para instruções de linguagem, como "for", "while", "if".
							---> construido os textos de definição para instruções for, while, if.

					---> construir os métodos tratadores de compilação para as instruções: for, while e if.


					--->realizando ajustes na classe PosicaoECodigo, há confusão entre o codigo na integra, e tokens obtidos neste codigo.
								--> modificações na classe PosicaoECodigo, levou a uma ordenação falha, só obtém colunas= -1.
								--> codigo fixado, mas não há o cálculo correto da  posição da produção.

____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scum 17.09:
		---> fixado a classe PosicaoECodigo, para calcular com exatidão a linha e a coluna do trecho de código. aguardando testes.
				---> verificando o código, constatou que os tokens do código são apenas termos-chave, e não os tokens originais. fixado, mais teste.
				---> falha nos testes, a malha de termos-chave está se repetindo, gerando estouro de indice.
				---> fixado, mas a ordem de sequencia de produções não está funcionando bem, e a malha não para depois que encontra todas produções.

				--- o código continua quebrado, na tentativa de achar a correta posição da produção perante o código, conseguiu, mas outras partes do código quebraram (método GetProducao()).
							--->fixado, feito no entanto várias inserções que tornam o código do método GetProducoes() menos robusto, a qualquer nova modificação.
							--->a classe PosicaoECodigo continua gerando posições falsas.
										-->ao que parece, o indice de comeco do trecho de codigo não está funcionando adequadamente.
										--->fixado, elminação de métodos Trim() e ajuste de indices para IndexOf(), que começa com 0.
										---> ordenar as produções com um método comparer pode estar confundindo a classe producao com a classe SequenciaID, pois uma é herdeira da outra, o que pode levar a erros na ordenação.

	   ---> construir os métodos tratadores de compilação para as instruções: for, while e if.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scum 18.09:
	Planejamento do dia:
			---> construir métodos tratadores de sequenciasID para while, if, e for;
						---> codificado métodos tratadores de sequencias id para instruções while, for, com bloco ou não.
						---> verificar se o problema de ordenação de produções seja por causa de uso de sequenciasID como produção.
									--> codificado um novo método na classe producao, para ordenar uma lista de produções conforme sua posição no código. Evita erros com classes herdeiras de produção. Aguardando testes.
						
						---> a codificar métodos tratadores de sequencias id para instruções if, com bloco e sem bloco.
						---> a codificar métodos tratadores de sequencias id para instruções else, com bloco e sem bloco.


	O que está impedindo para completar o dia:
			---> validar expressões lógicas, para controle de instruções if. exemplo: if  ((a==1) && (b==2)).
			---> pode ser que aplicando o PosOrdemExpressão capture erro nas expressões lógicas. segue em diante um algoritmo heuristico para obter uma expressão logica-condicional.

______________________________________________________________________________________________________________________________________________________________________________________________________________________
Tarefas para os próximos Daily Scrumm:

--> codificar:
		1 --->(feito) metodo de obter sequenciaid: termos-chave, parenteses--(tokens entre operadores parenteses), ; (final de sequencia), { ( tokens entre operadores bloco).
			--> se token="(", obtém tokens entre operadores parenteses, acrescenta a lista de tokens da sequencia, e continua o loop de tokens.
			--> se token= ";", retorna a sequencia.
			--> se token="{", obtém tokens entre operadores bloco, acrescenta a lista de tokens da sequencia, e retorna a sequencia.

			---> codificado, aguardando testes. O método ObterUmaSequenciaID() está na classe UmaSequenciaID().
					---> método ObtemUmaSequenciaID() foi movido para a classe UmSequenciaID, e substituido pelo método novo.

___________________________________________________________________________________________________________________________________________________________________
	    2---> (feito) metodo para obter expressões:
				
				--> se token="(", obtém tokens entre operadores parenteses, acrescenta a lista de tokens da sequencia, e continua o loop de tokens.
				--> se token= ";", retorna a expressão.
				--> se token=")", e pilhaInteiroDeParenteses<0, retorna a expressão currente.
			---> testes, falha na obtenção de tokens, não está reconhecendo o token ";".

		Prioritário:  (feito) ----> fixar o erro no método GetTokens(); quase lá, o último token não está sendo contabilizado.
					fixado, pode haver mais de 2 termos-chave juntos, que não foi calculado corretamente.

					(feito) fixar o problema de tokens termos-chave confundidos com ids polêmicos.
							--> codificado, aguardando teste.
					(feito) fixar o problema de operadores formados por dois operadores em sequencia na lista de tokens.
							--> codificado, aguardando teste.

					---> (feito)codificado uma nova versão do método GetTokens(), que verifica se cada termoChave da linguagem está presente no texto com tokens.
							----> falha na obtenção de termos-chave repetidos. Mas é um algoritmo compacto, mais conciso, e aguarda fixação.
									---> o processamento de tokens polêmicos fica fácil e simples de se verificar.
									---> o único problema é a presença de apenas 1 item de cada termosChavePresentes.

						(feito)	---> obtenção sucessamente dos tokens de termos-chave, continuando com operadores presentes.

						(feito) ---->  falta a correção de tokens operadores formado por dois operadores.


       	Anotação: o algoritmo ObterExpressao() em si, não estava errado, mas o método GetTokens() da classe ParserUniversal sim.

________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.09:
		
		--> (feito) novo algoritmo para GetTokens(), mais simples, mais robusto, captura tokens termo-chave falsos, testado sucessamente. captura também operadores que são feitos com tokens de outros dois operadores.
		--> (feito) testes para obterSequenciasID(): testes, falha, os tokens estão surgindo todos grudados e fora de posição certo,
					--> fixado mais um erro na obtenção de operadores nos tokens: um operador estava sendo contado em 2 vezes, por falta de "else" na malha de tokens de operadores.
					--->testes, fixado uma contagem de tokens parenteses como contagem de tokes da sequencia, testes sucessamente.
					--->aguardando o teste para todas sequencias de id do teste. testes, sucessamente.
	 	
	    2---> terminar o pacote mínimo de instruções: for, while, e if (faltando if). Guardar nas sequencias as instruções de linguagem de bloco, se houver bloco, mais a instrução da sequenciaID.
	
	    3 ---> modificar o método PosOrdemExpressao(), para tratar operadores unários em geral, e não apenas os operadores "+"e "-".

		4----> unificado vários métodos tratadores de escopo, para melhor controle de erros, pois o código de várias sequencias mapeadas está reunidas num só código de método tratador de escopo.

***************************************************************************************************************************************************************************************************************************
		5 ---> opcional: modificar o método Expressao.ObtemExpressao() para validar as variáveis da expressão, retornando um valor booleno confirmando a validação.
***************************************************************************************************************************************************************************************************************************

	    6 ---> um algoritmo heurítico para validar uma expressão logica: 
		---> na malha de tokens:
			---> começe com um "ID".
			--> se for ID, continue.
			---> se for Operador Não Condicional, continue.
			--> se for parenteses "(", obter tokens entre parenteses, e chamar recursivamente este algoritmo nas expressões entre parenteses.
			---> se for operador condicional, acrescente o operador condicional, e adiciona um "ID".
				a idéia é simplificar a expressão para uma avaliação de expressão condicional complexa.

	
		ANOTAÇÕES:  na classe expressoes, está os métodos ObtemUmaExpressao() que retorna os tokens da expressao mais próxima.
_________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.09:
	
		---> terminar a unificação de métodos tratadores de sequencias id para construção de escopo. (feito), alguns pontos como obtenção de chamadas de função não foi implantado.

		opcional: modificar o método Expressao.ObtemExpressao() para validar as variáveis da expressão, retornando um valor booleno confirmando a validação.
							---> será preciso tb validar chamadas de função, que eventualmente apareçam na expressão.
							---> PRIORITÁRIO: OBTER UM MÉTODO PARA REGISTRO DE CHAMADAS DE FUNÇÃO, COM VARIÁVEIS, EXPRESSÕES E NOMES_DE_FUNCOES.=====> codificado, aguardando testes.


		---> um algoritmo heurítico para validar uma expressão logica:  (este algoritmo é essencial para definição da INSTRUÇÃO IF).
			---> na malha de tokens:
				---> começe com um "ID".
				---> se for ID, continue.
				---> se for um nome de função, retira a chamada de função, e consome os tokens da chamada de função.
				---> se for Operador Não Condicional, continue.
				---> se for parenteses "(", obter tokens entre parenteses, e chamar recursivamente este algoritmo nas expressões entre parenteses.
				---> se for operador condicional, acrescente o operador condicional, e adiciona um "ID".
				a idéia é simplificar a expressão para uma avaliação de expressão condicional complexa.
___________________________________________________________________________________________________________________________________________________________________________	
Daily Scrum 22.09:

		---> um algoritmo heurítico para validar uma expressão logica:  (este algoritmo é essencial para definição da INSTRUÇÃO IF, ou a expressão condicional na instrução for, e expressão condicional de controle da instrução while).
		    ---> (feito) o algoritmo de resumir a expressão condificonal, conforme descrição que segue:
			---> na malha de tokens:
				---> começe com um "ID".
				---> se for ID, continue.
				---> se for um nome de função, retira a chamada de função, e consome os tokens da chamada de função.
				---> se for Operador Não Condicional, continue.
				---> se for parenteses "(", obter tokens entre parenteses, e chamar recursivamente este algoritmo nas expressões entre parenteses.
				---> se for operador condicional, acrescente o operador condicional, e adiciona um "ID".
				a idéia é simplificar a expressão para uma avaliação de expressão condicional complexa.

	opcional: modificar o método Expressao.ObtemExpressao() para validar as variáveis da expressão, retornando um valor booleno confirmando a validação.
							---> será preciso tb validar chamadas de função, que eventualmente apareçam na expressão.
		
   
  ---> testar o algoritmo de registro de chamadas de função.=====> codificado, aguardando testes.
			---> teses, falha no método MatchSequencias() (devido a unificação de vários métodos tratadores, que simplifica a correção de erros, e que será fixado em um método tratador).
				fixado, o erro estava no tratador de sequencias para definição de função. fixado o método tratador, estava com a contagem de tokens para parâmetro invalido, e contagem duas vezes os parâmetros, e com método de obter parâmetros com erros.


		   ---> fixar o método tratador de definição de função. (feito)
		   ---> codificar o método heurístico para validar uma expressão condificional. Codificado, aguardando testes. testes, sucessamente.
__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.09:

	----> testar mais o método de expressão condicional resumida.
	----> testar mais o método de registro de chamadas de função.

	---> codificado o método tratador de sequencias para a instrução if/else. --> codificado, aguardando testes de instruções: "for", "while" e "if".
	---> fazer o método ValidarExpressaoCondicional().---> feito, testes sucessamente!.

	---> planejamento das instruções da linguagem: Ao construir os Escopos, as sequencias originais encontradas são adicionadas como parte da instrução.
		
		---> blocos são adicionadas a lista de sequencias id do bloco. As expressões também estão guardadas na lista de expressões da sequencia.
		---> a indéia é formar as instruções da linguagem como sequencias id construidas na construção dos Escopos.


		---> planejar uma maneira de apresentar as sequencias id construidas como instruções compiladas.
				---> as instruções são composta de 3 partes: 1- nome da instrução. 2- expressões utilizadas na instrução. 3- blocos de sequencias id formadoras de blocos que são utillizados na instrução.
			    ---> uma maneira seria guardar em arquivo texto as três partes das instruções. as expressões são carregadas e inicializadas o escopo, os nome de instruções são código inteiro, os blocos são carregados os códigos, e inicializadas o escopo as expressões de cada instrução.

	   ---> codificar novas instruções, como "atribuiçãoDeVariaveis", "chamadaDeFuncoesOuMetodos".
			---> não esquecer de esvaziar a lista de sequencias originais depois que uma instrução foi compilada. (movida para a classe escopo, não é necessário esvaziar a lista).
___________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.09:

		---> lista de sequencias id encontradas no processador de id, movidas para a classe escopo. Essa lista estava colocada no processador de id confusamente.


		---> codificado a avaliação de expressões de inteiros. O código depende da implementação de métodos de operadores de inteiros nativos.
					---> com esta implementação, não é possível estender operadores do tipo int, pois o código da operação é feito com funções nativas;
		---> codificado a avaliação de expressões de ponto-flutuante.
					--> também nesta implementação, não é possível extender operadores tipo float, pois o código de operadores é feito com funções nativas.
		
____________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.09:


		---> codificado uma classe EvalExpression para objetos.
		---> codificado uma classe EvalExpression para string. (tem operações nativos para string).


		Anotação:  as classes EvalExpression estão codificadas para otimizar expressões "int" e "float".


		---> codificado o método tratador de sequencias id para a instrução atribuição.
		---> modificado a classe Funcao, para contér as instruções VM que comporarão o corpo da função. Antes somente havia os tokens do código, e as produções da função, o que em runtime pouco valem.



----> o que falta para codificar nesta Daily:
		---> codificar novas instruções "chamadaDeFuncoesOuMetodos", e "return";
		---> codificar o método para ChamadaDeFuncao(), na classe Funcao; no atual estágio, somente métodos definidos na linguagem base do projeto estão avaliáveis.
---> impedimento do dia:
		---> planejar uma sequencia id para o termo-chave "return".

________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.09:

	---> codficado uma classe EvalExpression para avaliar expressões condificionais. : aguardando testes.

	---> codificado o procesamento em tempo-de-execução das instruções: for, while, if/else.
			---> falta validar se uma expressão é de atribuição, condicional, ou incremento aritimetico. codificado, favor verificar se o método PosOrdem pode capturar erros de colocação de operadores e operandos.

	---> codificando para uma expressão conter expressoes como seus elementos. 
	     Isto possibilita composição de expressões com ChamadasDeFuncao() serem guardados em uma expressão, como um elemento (sub-expressão) da expressão.

________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.09:
	
	---> modificação de expressão com ItemsExpressão completado, compilado, fixado.
				---> testes para obter expressões, com tokens polemicos, sucessamente. fixado excessões, testes sucessamente.

Atividades do dia:
	---> verificar se o método PosOrdem pode capturar erros de colocação de operadores e operandos.

	---> codificar novas instruções "chamadaDeFuncoesOuMetodos", "atribuição de variável/propriedade", "return";
			----> a instrução return pode ser feita empilhando o resultado.. Falta planejamento.

	---> modificado as classes EvalExpression parcialmente, para conter sub-expressões, mas que não foi implantado a chamada de função da sub-expressao.
			---> foi codificado uma classe para avaliar funções, recursivamente, mas o tipo de retorno falta a definir.
 
______________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.10:	
	---> codificado a avaliação de expressões-elemento funções nas classes Eval, todas classes tem analisador de chamadas de função, e a classe EvalFunction faz a chamada de função.
	---> verificado o método Pos-Ordem não captura erros dentro de uma expressão. E processa sem erros uma expressão com erros.
				----> é preciso criar um método para validar expressões.
							(falta a inclusão do caso de uso: operador unário.).
							---> testes para obter expressão resumida, houve falhas no método BuildAllEscopos(), sem erros fatais, mas sem registrar uma expressão.
											-----> encontrada a falha, não há sequencia id mapeada para processamento de expressões com atribuição.
							---> houve falha na transmissão do escopo, no método BuildEscopos(). Verificado, não houve falha na transmissão de escopo, mas a expressão do teste está sendo guardada como variáveil, não expressão.
							
			  ----> construção de expressões no teste feito, aguardando o teste para obtenção de sequencia resumida genérica.

			  ---> codificar na classe TabelaDeValores, todos métodos com obtenção e manutenção de variáveis, pois houve divisão entre variáveis "int", "float" e "object (genérica)".
						---> método afetados: GetVariavel(), GetTipoVariavel(), RegistraVariavel().
_______________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.10:	

---> impedimentos do dia:
	---> como modificar o método GetTokens() da classe ParserUniversal.

	----> modificação na herança de Expressao e ItemExpressao. A herança de expressoes e itemExpressao está funcionando adequadamente.
	----> modificação na classe Expressao, inclusão de expressão-elemento-função como sub-expressão.
			---> falha no cálculo do primeiro elemento da expressão, está constando como Expressao, mesmo se for ItemExpressao.
								---> fixado! No construtor de Expressao, estava incluido uma Expressao no primeiro elemento subExpressao.

	----> método ObtemExpressaoGenericaResumida, fixado, testes sucessamente.
			----> codificar o método ValidaExpressaoGenerica(), que faz uma validação de uma expressão com IDs e OPERADOR_BINARIO.
			----> modificar o método ObtemExpressaoGenericaResumida(), para obter operadores unários na lista de tokens da expressão.
			----> método principal: ValidaExpressaoGeral() testado sucessamete. Mas não está incluso a avaliação de OPERADOR_UINARIO.
			----> método ObtemExpressaoGenericaResumida(), extendido para comportar OPERADOR_UNARIO.
			----> método ValidaExpressaoGeral(), modificado para ter regras de negócio com OPERADOR_UNARIO.

    ----> encontrado um erro não fixado na determinação de operadores polêmicos no método ParserUniversal.GetTokens().
		  O método GetOperadoresPolemicos()  não estava "ativado", no código do método GetTokens().	
		  O erro não fixado não retorna operadores unários. O operador unário "--" não está na lista de operadores unários.

		  -->Verificado o operador unário está na lista de operadores unários da linguagem, mas não está presente na lista de operadores do método ParserUniversal.GetTokens().
		  -->ativando o método de GetOperadoresPolemicos(), e criando um filtro para duplicações de operadores, no método, resultou em uma lista sem duplicatas de operadores polêmicos...
	
	
	---> o que falta: investigar a não presença do operador unário "--";
				---> encontrado uma falha no método de testes, o código total estava sem a presença da expressão 2 a ser analisada...
				---> quebra de código, na determinação de operadores presentes, no método ParserUniversal.GetTokens();
								---> fixado, de repente apareceu um erro na procura de operadores presentes, que foi fixado.
								---> a falha continua no método GetTokensPolemicos(), que está apagando os tokens polemicos, e não repondo o token unificado.
								---> na ordenação de operadores pelo seu cumprimento, elimina a busca de operadores polêmicos (operadores formados por outros operadores!).

			  --> deteminação correta de operadores presentes, pela ordenação de tokens operadores pelo seu cumprimento, decrescentemente, não precisou do método GetOperadoresPolemicos() (operadores que são a soma de outros operadores, como "++" , "--" !!.
						---> mas uma possível futura falha, em operadores formados por palavras, pode se confundir com tokens IDs.. É preciso do tratamento de termos-chaves presentes, aplicado para operadores presentes.
			   

   ---> ESTUDAR UM MÉTODO PARA TORNAR TESTES MAIS EFETIVOS. O método ParserUniversal.GetTokens() tem erros que são sutis, mas um bom método de testar situações "fronteiriças" tem que ser codificado.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.10:	

---> codificar a procura de operadores formado por palavras, e que podem se confundir por tokens ID. Aplicar o trecho de código para procurar termos-chave presentes, para a procura de operadores presentes.
				--->codificado a procura de operadores com  operador.caracterVálido[0] e eliminação de palavras que podem confundir.

---> teste para ObterExpressaoGenericaResumida(), pois tokens de operadores unários estão sendo encontrados adequadamente.
		---> testes, parece que a expressão geral resumida está certa, mas a análise da expressão é mais difícil que previsto.

---> codificado a prevenção de erro com token ";" no método MacthSequencias(), quando o token ";" é também do token mapeados, e encontrar uma expressão consome este token.

---> quebra do código de obter escopo, no método BuildAllEscopos().
			---> investigando o erro, constatou-se que os tokens do código do cenário do teste estava incorreto, mudando os tokens para a lista correta, o método BuildAllEscopos() voltou a funcionar O(não estava registrando as variáveis e expressões, pois o método tratador de sequencia voltava false, antes do registro de variáveis e expressões).

---> testes para ValidaExpressaoGeral(), o primeiro caso resultou em [true], a expressão estava com operadores e operandos colocados corretamente,
	mas no segundo caso resultou em [false], favor verificar a expressão a ser validada, no segundo caso de uso.


Atividades do dia. O que impede fazer as atividades do dia?
	---> planejamento de "ponteiro IP de instrução", para criar a sequencia id "return".

	---> 1- investigar o segundo caso de validação de expressão, no teste TesteObtemValidarExpressaoGeralResumida().
				---> houve uma falha numa das regras de negócio para validar a expressão geral resumida: uma das condições era "x==0", e teria que ser "x>=0".
				---> validação de operandos/operadores quaisquer expressão operacional!!

	---> 2- codificar novas instruções "chamadaDeFuncoesOuMetodos", "atribuição de variável/propriedade", "return";
			----> a instrução return pode ser feita empilhando o resultado.. Falta planejamento.

			----> para atribuição de variáveis/propriedades, utilizar as classes EvalExpression.(feito)
			----> falta um método para inicializar variáveis/propriedades. feito, método InstrucaoAtribuicao() faz o cálulo.


	---> auto-organização da "equipe":
		---> PROPOSTA PARA MELHORES TESTES - 1: Codificar sempre DOIS TESTES: um que falha, outro que passa.
						   - 2: Codificar TAMBEM cenários de testes para "dados fronteiriços".	
						   - 3: FAZER MAIS ENTRADAS PARA UM MESMO TESTE. A teoria recomenda que os testes sejam para um cenário, mas não diz nada se há mais de uma entrada para um cenário de teste.
						   - 4: FAZER UM TESTE PARA CADA DESVIO DE FLUXO NUM MÉTODO.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.10:	
--> 1- codificado um método para validar encadeiamento de propriedades, na classe expressao.


--> 2- codificar novas instruções "chamadaDeFuncoesOuMetodos", "atribuição de variável/propriedade", "return";
			----> a instrução return pode ser feita empilhando o resultado.. Falta planejamento.
						---> planejamento feito, foi criado uma pilha de chamadas de métodos, e um campo na classe instrução que guarda um valor inteiro de ip (instruction pointer).
							 estrutura de Dados: ProgramaEmVM.Pilha<int> pilhaDeChamadas.


			----> codificado a instrução atribuição de variável/propriedade, e na mesma instrução, a definição de uma propriedade seguida de uma atribuição.
			----> codificado o método tratador de chamada de função, dentro dos métodos tratadores de função:
					---> ChamadaAFuncaoSemRetornoEComOuSemParametros();
					---> ChamadaAMetodoComOuSemParametros();


			----> codificado a soma de instruções com  blocos de SequenciaID/ ou com blocos de instruções.
		  
		    ----> incluir nas validações de expressões (instruções "for", "while", "if/else"") a validação por resumo genérico,  codificado na classes expressoes.
		    ----> pronto para codificar a chamada de função/método e o comando [return].
			----> classes Eval modificadas, para compor avaliação da expressão e estocar na primeira variável da expressão, se houver uma atribuição na expressão.


O que é impedimento para o dia?
			
			----> incluir nas validações de expressões (instruções "for", "while", "if/else","atribuição", "chamada de função") a validação por resumo genérico,  codificado na classes expressoes.
		    ----> pronto para codificar a chamada de função/método e o comando [return].			
________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.10:	

		---> nova funcionalidade: operador maticial [].
		---> modificando as classes Eval.
		---> codificado a obtenção de expressoes, para compor o operador matricial como uma sub-expressão.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.10:	

		---> fazendo as modificações do Gerenciamento de Mudanças:
				---> modificando a classe TabelaDeValores, para definição de VariavelVetor (novo tipo de Variavel), com funcionalidades de adicionar, remover, e obter elemento a partir de um indice inteiro.
				---> modificando as classes Eval para compor operadores matriciais.
				---> modificando a classe Objeto, para inicialização de um Objeto (criando a lista de propriedades, é tudo que se precisa para alocar memória para um novo Objeto!).
		---> a fazer: otimização na avaliação de expressões, com uso do padrão de projeto "Observer".
					---> iniciando a codificação, obtendo métodos Get/Set para variaveis. Terá um hook para notificar expressões que uma variável foi modificado.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.10:	
		---> completada a funcionalidade de expressões não modificadas: hook nos SetValueVariavel, criação de um objeto "oldValue" na classe Expressao,
			cálculo de expressões nas classes Eval, para retornar o oldValue se as variáveis da expressão não forem modificados.

		---> refatorando a classe TabelaDeValores, movendo Gets/Sets de Variaveis, para as classes de variaveis.

		---> codificar um teste para obter uma expressão com operadores [].
					--> codificado, efetuado, fixado, obtenção de expressões com vetores feita sucessamente.
					---> para testar as classes Eval, será preciso registrar vetores no escopo do teste.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.10:	

		---> modifcar a classe Expressao, para criação de duas novas subclasses, FunctionExpressao, e VectorExpression.
						----> codificado, fica mais claro e legível o tratamento de expressões que são chamadas de função, e expressões que são chamada de vetor.
						----> modificado o construtor da classe Expressao, para compor VectorExpressao como elemento da Expressao. 

		---> confusão entre classes e subclasses para Expressao e ElementoExpressao, fixado.
					---> testes sucessamente com construtor de Expressao, para compor expressões vetor.
					---> modificações nas classes Eval, aguardando testes.

		---> testar as classes Eval, com expressões com vetores e expressões com chamadas de função.

		---> fazendo uma análise de desempenho x simplicidade, concluiu-se que o uso de variáveis de tipo específico,
			talvez não tivesse tanta otimização, e a simplicidade não afeta o desempenho se não estamos utilizando dados em massa, como variaveis vetor.
			Uma otimização poderia ser feita para VariaveisVetor(), devido ao uso maciço de dados. O uso de classe de objetos específicas, como Bitmap, para imagens, já está otimizada, se não utilizarmos variaveis dentro das operações com pixeis.
			No caso particular de imgens, poderia ser feita uma otimização que envolve as coordenadas e uma operação de pixel específica, que não envolvesse variáveis da linguagem orquidea.
			é o que se observa em linguagens como PHP..
					---> considerando isso, foi feito uma simplificação total nas classes Eval para tipos específicos, ficando apenas a Eval para objects, e Eva para functions.

					---> fixar o codigo da instrução "for", que está incompleta. Uma boa olhada na instrução "while" pode auxiliar.
________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.10:

			----> teste para classe Eval Expression.
					---> expressão para PosOrdem feita sucessamente.
					---> avaliação da expressão falha, o retorno é null.
							---> codificar novamente a classe Operador, para suporte de operadores nativos.
							---> suporte a operadores nativos presentes, mas as operações estão na pilhaOperacoes, e deveria estar na pilhaInteiros, pilhaPontoFlutuantes, pilhaStrings, ou pilhaObjetos.
							---> modificação das pilhas feito, testes, falha no cálculo do valor correto da operação do teste.
 

			----> fixar o código da instrução "for".

_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.10:
		---> codificado as classes VariavelExpressao,  VariavelVetorExpressao, OperadorExpressao, FuncaoExpressao, que resulta num código de mais legibilidade,
			e otimiza o desempenho das classes Eval.

		---> devido à modificação do código, testar novamente as classes Eval.
					--> quebra do código de PosOrdem(), devido às mudanças feitas para compor as várias classes Expressao.
								---> com backup do código, foi possível fixar o método PosOrdem().

					--> codificar o método ToString() para compor diversos elementos.
								--> quase lá, o método ToString() não está registrando bem o nome dos operadores da expressão.
										---> fixado, o código do Operador.ToString() estava quebrado.
										---> fixado o método expressoes.ToString(), foi necessário implementar os métodos ToString() para cada classe Expressao.

			----> continuando o teste para as classes Eval, falha, o código está quebrado. (foi necessário alterar o código para melhor desempenho, e mais legível e mais fácil de manter, criando classes Expressao).
							---> investigando, a construção de uma expressão está quebrado. fixado.
							----> testes, falha, o método PosOrdem() não retorna os operadores. fixado,  a lista str_operadores de operadores da linguagem estava vazia.
							----> testes, falha, o método Eval() retorna um valor diferente do esperado. o método PosOrdem() continua quebrado.
							----> fixado, houve confusão entre tipo de operador e tipo de modalidade do operador (binario, unario, etc...).

				---> testes feitos sucessamente. conforme a sprint review da sprint anterior, recomenda-se mais testes.
							--> testes com subtração, falha no resultado, e o método PosOrdem() está substituindo o operador "-" pelo operador "+", resultando em "ab+" e não "ab-".
										---> é falta de paciência... os dados do operador foi alterado, o tipo, que deveria ser: "BINARIO" ou "UNARIO", está registrado como "in".
										---> mudando para expressão "a-b", foi calculado corretamento a expressão em PosOrdem, e o resultado da avaliação foi o esperado.

						   ----> testes com expressão "a*b", falha, o sistema teima em retirar o tipo do operador, que deveria ser "BINARIO", mas foi modificado por "int".
										---> como o sistema em retirar o tipo do operador, foi modificado para obter a lista de operadores a partir da linguagem, e não do repositório de classes.
										---> o teste passou.

			  ---> continuar com mais testes, com dois ou três operadores numa expressão.
								----> nova funcionalidade: variáveis números podem entrar no cálculo.	
								---> retirada a atribuição de valor para a primeira variável da expressão. verificado a instrução de atribuição, se avalia e atribui à variável a ser atribuída, se o hook de otimização é chamado (com um Setter para variáveis).


_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.10:

			---> testes para classe Eval, com mais de um operador, falha no método PosOrdem(), não está registrando todos operadores, e quando registra, o contéudo é null.
								---> fixado, no cálculo de operadores restantes, foi utilizado na busca um operador pop() da pilha, que era modificado a cada busca.. fixado, testes sucessamente.
								---> fixado o construtor da classe Expressao, não estava registrando um  número como elemento da expressao currente.
								---> Expressao com mais de um operador, e com número, teste sucessamente.
		    ---> testes com funções dentro de expressões postergado, ainda não há código para funções da linguagem orquidea.

			---> métodos construtor de expressao, posOrdemExpressao(), e classe Eval, operacional!

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.10: (continuação)

	---> Anotações:instruções: "for","while","if","atribuição/inicialização de variáveis"codificadas,"return" ,próxima instrução:  "chamadas de função" 
			--->ANOTAÇÃO: A CHAMADA DE FUNÇÃO DEVE GUARDAR O IP NA PILHA DE IPs.

	----> (feito, aguardando testes):
					continuando com o Sprint Backlog do projeto, é preciso verificar as instruções da linguagem, olhando a instrução "for", por exemplo, parece que não está funcionando muito bem.
					---> verificado instrução "for", fixado o código.
					---> verificado instrução "atribuição", acrescimo de processamento de variáveis de controle.

					---> métodos de instruções modificado para retornar blocos codificada como uma instrução bloco.
					---> métodos tratadores para Atribuição, if, else, for, fixados.

		----> anotação: foi incluindo um texto contendo template de informações sobre as expressões utilizadas nas instruções.
		

	---->(a fazer):
				(feito) planejamento para a instrução "return", é preciso uma pilha de chamada de métodos, e uma variável booleana em cada instrução, que indica que a chamada de uma função retornou um resultado.
							--->(feito) codificada a instrução return, mas é preciso setar nas instruções de chamadas, o push de IP, o IP da instrução.

				---> (feito) cada chamada de função tem que guardar o id da instrução de retorno (cada expressão tem um ID utilizada para retorno).
				---> cada instruções pode/ou não calcular o resultado de uma expressão, dependendo da variável booleana que controla o retorno para a instrução, após uma instrução "return" for avaliada.
				---> (feito)nova funcionalidade na classe expressão: resolver problemas de ambiguidade entre operador que é binário e unário ao mesmo tempo. testes sem as regras, sucessamente.


	----> terminar os métodos tratadores de chamada de função (feito), e criar a instrução chamada de função.(a fazer).

	----> (opcional) testar o método Expressao.ObtemChamadaDeFuncao(), se os parãmetros estão sendo calculados corretamente.
					---> verificado, codificar um  extrator de expressoes.

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.10: 
	----> terminar os métodos tratadores de chamada de função (feito), e criar a instrução chamada de função.(feito).
				---> resultado da chamada de função é guardada na pilha de objetos, da classe OperadoresNativos.

	----> testar o extrator de expressoes, em ExtraiExpressoes(), na classe Expressoes. (feito).
				--> fixado, testes sucessamente. Utiliza este método para obter chamada de expressão.
			


	----> codificar as instruções "break", e "continue", dentro das instruções "for" e "while", no processamento de blocos, ou qualquer caso! . (feito)
				---> codificar os método tratadores para tokens da linguagem "break", e "continue". Uma sequencia id contendo apenas um token ("break" ou "continue") para mapeamento de sequencia do método MathSequencia().
							---> acréscimo de tokens chave "break" e "continue", como producoes da linguagm orquidea.
							---> codificado, aguardando teste no método BuildAllEsccopos(), para as novas sequencias id: "break", "continue";


	---->o que falta:
		---> verificar a método tratador ChamadaDeMetodos(), utiliza um método auxiliar que está desatualizado.
		--->  (feito) planejar o retorno para a instrução, se o valor calculado é recebido, no método chamada de função, e tb a mudança do ponteiro-instrução IP.modificações na chamada de função, para retornar um valor.
					---> verificar se há avaliação de função não nativa, com uso de tokens da linguagem orquídea. Não há função com instruções orquidea.
					---> o retorno da função fica armazenado no tipo de retorno da função (funcao.retorno).

________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.10:

		---> planejar e codificar um método de retorno de avaliação de funções.
				----> planejado, codificado, o retorno de função fica numa variável de escopo.
				----> atualizado o controle do fluxo de instruções para todas instruções.

		---> mudanças feitas na classe Funcao, com geração de escopo próprio,  gerou um loop infinito, pela propriedade LinguagemOrquidea linguagem, o que foi resolvido mudando essas propriedades para estática.

		---> modificação na maneira de seguir o fluxo de instruções, para mais intuitivo e simples no desempenho.		

		---> iniciar testes para instruções da linguagem.
					---> testes para instrução if, fixado um erro de não inicialização das propriedades , na classe ProgramaVM, instrução if avaliada sem erros fatais.
							----> continuando os testes, falha na parte lógica da instrução if. O condicional tem resultado um inteiro ou float, não um bool.


________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.10:

		----> testes para a instrução if/else, o método PosOrdem() não reconhece operadores condicionais.
			---> fixado, quase lá, o teste não constroi os blocos de instrução. É preciso construir a instrução do bloco. 
						----> construido, testes, falha na parte lógica da instrução (resultado não é o esperado).

						---> modificado o codigo, nao está acessando as expressões da instrução if/else.
									---> fixado, mas não resolvido ainda a obténção de variavel simples ou composta para instruicao de atribuicao.
									---> fixado, o nome da variavel é obtido do metodo expressoes.ToString(), testes sucessamente.

						---> com estes testes, foram testados sucessamente as instruções if/else, e atribuicao. A dificuldade foi fazer o cenário do teste, pois não se utilizou o construtor de escopos, com validação de variáveis, expressões e termos-chave.
										----> recomendado mais testes.

						---> implementado a forma de avaliação de instruções, mais rápida, e possibilitando a adição de novos tipos de instruções.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.10:
		----> codificado teste de construção de escopos com o metodo BuildAllEscopos(), para tornar mais fácil os testes para instruções.
				----> testes, falha na construção de método tratador para instrução "while", não encontra método tratador para a sequencia. Mudança na sequencia id mapeada..
						---> mudança nos tokens resumidos, para conter um resumido= BLOCO.
								---> terminar a codificação de BuildAllEscopos, para pegar sequencias id dento de blocos.
								---> método BuildAllEscopos() rodando sem erros fatais, porém para a sequencia de instrução while, não consegue o match de sequencias.

								--> codificado o método de ObterSequenciasResumidas para compor o resumo "BLOCO", e modificado o método MatchSequencias(), para resumir a um BLOCO, os tokens de bloco.
										---> testes falha, o código do método  MatchSequencias() está quebrado, justamente no método que produz EPRSS E BLOCO.
										---> investigando, o método Expressao.Instance.ObtemUmaExpressao() está quebrado.
													---> código problemático, fazer outro método para obter a primeira expressão dentro de uma lista de tokens.
													---> codificado um novo método para obter a primeira expressao dentro de uma lista de tokens.
																---> falha no teste com o novo método de ExtraiUmaExpressao(). testes, continua a ocorrer exceção, o método ObtemUmaExpressao retorna um valor não esperado.
																---> o teste de matchSequencias passou para este cenário, mas o processamento após o método MatchSequencias() está quebrado.

							--> uma sugestão: deixar o método obtemSequenciaResumida simpplificar os IDs em EXPRSS, na sequencia original.

							---> testes, o método BuildAllScopos() passou no teste.
									---> seguindo o teste, falha no método BuildInstrucaoWhile(), tentativa de acessar um bloco vazio.fixado, expressões e blocos sendo achados sucessamente.
									---> o acréscimo da instrução já construida, para a VM, resultou em um loop infinito.
												---> fixado, os blocos da instrução já esta construidos nos metodos BuildAllEscopos e MatchSequencias, e também na construção das instruções.

							---> o teste para obter uma instrução while passou num teste. 


									---> o que vale é que pode-se testar qualquer instrução através da declaração do texto do código contendo variáveis e as instruções, o que simplifica a construção
									de cenários de testes. 
												---> pode-se fazer mais dados de entradas do cenário de teste, para obter uma cobertura mais ampla dos testes.


									---> instruções atribuição, if/else e while testados uma vez sucessamente.Mas não está registrando as variveis definidas e inicializadas. Falha no método MatchSequencias, instrução: int a=5;
												---> construção de instruções que captura erros na compilação, colocando mensagens de erro na lista de erros do Escopo.


_________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.11:
			---> fixar o não registro de atribuição na sequencia "int a=5", problema no método MatchSequencias().
			---> codificar operadores "=" para strings, bools, e chars, no método linguagemOrquidea.InitOperadores.
						---> método BuildAtribuicao() não tem o caso de VariaveisVetor. implementar.
				---> teste BuildInstrucaoAtribuicao() passou.
				---> teste BuildInstrucaoWhile() falhou. no método MatchSequencia(), não bem calculada a expressão de controle de while. Por que? Porque não registra o primeiro token da sequencia.
						---> fixado, um erro na construção de Expressao, não registrava um ID, pois a sequencia de elses não permitia chegar ao caso certo.

				---> falha na validação de expressão condicional no metodo construtor da instrução "while". Método Convert(Expressao) nao está funcionando bem.
					----> fixado o método Expressao.Convert().


					----> verificar novamente o registro de variáveis, e mensagens de erro no escopo.

							----> todas construcoes de instrucoes foram modificadas, retestar.
									----> fixado o indice de´método tratador, com o MatchSequencias().
									----> retestado a construção de instrução de atribuição.
									----> retestado a construção de instrução "while".

						   ----> continuar os testes de construção de instruções.
	---> codificado método auxiliar para cenário de testes de construções de instruções.
							---> teste pronto para avaliação de instrução "for". testes sem erros fatais, porém não retorna o valor esperado.
										----> modificações no método MatchSequencias() quebrou o código deste método. fixado, com uso de backup de arquivos..


						   ---> incluir sequencias de id para instruções "while", "if/else", "for", sem blocos, apenas uma instrução como bloco.

__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.11:
		---> fixado o construtor de atribuição, mas na instruição "for", a atribuição não está funcionando bem.
					---> investigando, o MatchSequencias() para instrução "for" não está funcionando bem.

		---> construtor da instrução "while" está com registro duplo da variável de controle. fixado.
					---> validação da variável de controle da instrução "while" está incorreto.

		---> construtor da instrução atribuição está livre de erros.

		---> construtor da instrução "while" não está sendo reconhecido. fixado, mas a mensagem de erro está com a sintaxe errada. fixado, houve um erro de sintaxe de Português no texto da mensagem de erro.
			----> construtor da instrução "while" está livre de erros.

		---> construtor da instrução "for" não está sendo reconhecido.

----> opcional: mais dicas matemáticas, no método MatchSequencias, se encontrar um "ID", fazer o processamento de resumo de expressões..
				---> o método de processamento de resumo de expressões está funcionando para a intrução: "while".

				---> método MatchSequencias() processou corretamente a instrução "for", porem , na última expressão, não saiu legivel os elementos da expressão. 
				fixado, o tipo da expressão era default "float", e o operador "++" não tem no tipo "float". 
				O tipo "int" é mais preferível, pois contém todos operadores do "float" e mais. O valor default (se não encontrar o tipo da expressão), é "int",
							---->construção de expressões sem o operador ponto-e-vírgula na extremidade.

				---> um novo insight levou a extensão de uma expressão (EXPRSS) ser tratada como um ID, pois um ID também pode ser uma expressão! modificações feitas permitiram o bom mapeamento de sequencias ID definidas, para as instruções "for" e "while".

				---> reconhecimento para instrução "for" rodou perfeitamente.
							--> obtenção do valor para a variável de controle, falha. é erro de registro de variáveis.
				---> reconhecimento para instrução "while" rodou perfeitamente, mas houve uma adição de escopo-folha desnecessãrio, e que gerou 58 mensagens de erro, também desnecessário.

					---> validação da instrução falha: econtrada muitas expressões (>30), e erro no processamento de setar o valor da  variável de atribuição, com a classe Eval.
								--> fixado a falha de muitas expressoes, a lista de tokensExpressoes não estava sendo esvaziada a cada passada da malha no método MatchSequencias().


__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.11:
				---> encontrado um problema de design: o método PosOrdemExpressao não aceita tipos do elemento de atribuição, retorna nulo.
							---> fixado, o método PosOrdemExpressao() pula tokens que sejam tipos de classe.
							---> fixado a instrução "for". funcionalidade de definição da variável de inicio da instrução for, fixada.

				PROPOSTA PARA UMA MUDANÇA: simplificação das sequencias id mapeadas, retirando também os tratadores variantes, e dando mais processamento para os métodos tratadores, que fariam a validação de sequencias id semelhantes entre si.
							---> analisar e relatar o mapeamento de sequencias id, muitas sequencias id estão sendo feitas como variantes de um mesmo tpo de sequencia id.
							---> há sequencias com mesmo método tratador. Mudança aprovada, retirada as sequencias id com tratadores duplicados.

___________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.11:
			----> sequencias redundantes retiradas.
			---> fixado erros na construção da instrução "while", não estava validando as variáveis na expresão de controle.
			---> teste para falhar, não falhou, mas uma expressão formada por variáveis inicializadas não acusou o erro.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.11:
			--> testes para a sequencia "i=i+1", falha, há um problema de indices.
						---> regressão para teste de sequencia "while", o código não quebrou.
						---> no caso de expressão: se o token de igual "=", for encontrado, é porque a expressão foi encontrada, e vai até o token igual "=".
								---> correção deste caso, testes sucessamente.
						---> como o código foi modificado, testes novamente para o caso "for", falha, parece que a presença do token ";" no meio da sequencia, quebra o código.
									---> fixado, na sequencia mapeada não estava escrito o sinal de igual, que é um marcador, não um ID ou operador. Com isso, o código foi fixado, acrescentando o sinal de igual na sequencia mapeada.
									---> testes também para a outras sequencias id do teste, o código não quebrou, encontrou o indice do método tratador, mesmo que as variáveis não estavam registradas.

ANOTAÇÕES DE ESCOPO DE SPRINTS:
O QUE FALTA NO PROJETO COMO UM TODO!
	---> mais testes de tipos de instrução.
	---> criar classes de integração entre POO, LISP e PROLOG.
	---> suporte a redes neurais matriciais.
	---> teste para um programa completo.

					----> continuando os testes.. Teste para instrução if/else. Falha no teste de atribuição!! O código quebrou.
							---> o codigo quebrou porque a obtenção de tokens expressão foi modificado para ir até o signal de igual, fixado, mas pode gerar erros indesejáveis em outras partes do código.
							---> teste instrução "if/else" sucessamente.

_______________________________________________________________-_________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.11:

Já feito, mas para registo de continuação..

    ----> codificação de métodos de instruções da linguagem da VM para rodar um programa.

			---> planejamento da classe Instrução.
			 1- Um instrução contém uma lista de expressões, 
			 2- opcionalmente uma lista de instruções de blocos,
			 3- e o método de chamada da instrução.
			 4- um endereço de ponteiro IP,  e uma pilha de endereços de chamada de métodos, para controle de retorno de chamadas de funções.

	----> construção de instruções "defnição de função/método", "Classe".

			---> insight: nova instrução: "new", ou "Create" para construir um objeto, a partir da definição da classe.
			---> para melhor desempenho, será movida as instruções do no BuildAllEscopos, para o escopo. fica mais claro, mais intuitivo em seu design.

			---> dificuldade do dia: como compor as instruções de um bloco, representado por uma sequencia?
	
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.11:
	----> planejamento para a definição de função e construtor: Já está codificado o Build, faltando transformar os dados passados pelo build, para um conjunto de propriedades e instruções para um método construtor, pu parâmetros para um método comum.
	----> codificar a obtencao de um código, a partir de uma sequencia id no Build. codificado.
	----> codificado a instanciação de um Objeto, com  propridades vindas da definição da classe!

			---> revisado os métodos tratadores de definição de métodos/funções, e chamadas de funções/métodos.
			---> criado a instrução "callerFunction" (chamada de função/ método).
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.11:
			
			---> nova instrução: GetValor(variavel): retorna o valor de uma variável, util em instruções como "chamada de função".
		
			---> continuar os testes para instruções..
						--->testes para definição de função, encontra o tratador de sequencias correto, mas não registra a função na tabela de valores.
									----> fixado a falta de sequencia id do código do teste. 
									----> fixado também o retorno antes de registrar na tabela de valores a função encontrada.
									----> a fixar o reconhecimento de sequencias id variantes.

				---> verificar o indice de inserção de sequencias variantes. verificado, o indice estava errado na posição de inserção de sequencia variante.
				---> simplificar os ids de parâmetros para definição de função, como nas sequencias de instrução, os ids exprss foram resumidos de EXPRSS-->ID.
						---> fixado o erro no método ResumeExpress, os cálculos de ids estava feito nos tokens originais.
						---> acréscimo de uma nova regra heuristica para extrair uma expressão, baseado na sequencia de dois ids seguidos.

		---> testar o método MatchSequencias(), com nova sequencia de ids para definição de função sem corpo.
				---> nova regra heuristica para extrair expressoes. fixado, o MatchSequencias() vai até o indice variante, corretamente.
						
		

		---> é preciso rever o código de achar sequencias variantes.
						---> simplificado o processamento de seuquencias variantes, é preciso rever o código do método MatchSequencias(), na parte de processamento de sequencias já mapeadas variantes.
									----> fixado, o código retorna as sequencias variantes também.



RESUMO:
		---> método MatchSequencias() fixado, retorna a sequencia principal, e as sequencias variantes estão sendo acrescentadas corretamente.
		---> nova instrução: GeVariavel(variavel): retorna o valor de uma variável, util em instruções como "chamada de função".

		---> método BuildAllEscopos() está em loop infinito! ----> pronto para fixar o erro, a seqMapeada está com o break correto.
				
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.11:

		---> codificar uma nova instrução: SetVariavel(nomeVariavel, tipoVariavel, Escopo). Com a instrução currente, é possível criar e ler variáveis dentro do código da linguagem. codficado aguardando testes.
		---> implementar o casting para expressões! (converte os tipos de parâmetros, se forem de tipos diferentes. 
		---> verificar o método ExecuteFunction() parece que vai quebrar. fixado, aguardando testes.



		---> encontrar possiveis funcionalidades para VariavelVetor, comparando com as funcionalidades para Variaveel.
		---> método BuildAllEscopos() está em loop infinito (problema no método MatchSequencias())! ----> pronto para fixar o erro, a seqMapeada está com o break correto.
				---> investigando, o método de cortar exrpressões para formar um id estava muito complexo e pouco simples. O código foi modificado.
				---> fixado o método MatchSequencia() que estava entrando no loop infinito.
	

impedimentos do dia:
		---> onde codificar o Casting?, na classe Eval? Haverá perda de desempenho? implementado na classe Eval, casting para variaveeis.
				---> não há perda de desempenho, pois a avaliação de expressões vem otimizada. (Resolvido).
				---> codificado, mas falha, na classe Eval o Casting().

faltando as funcionalidades:
				---> tornar operacional o Expressao.Casting(). fixado.
				pela modificação na classe ProcesadorDeID, o cóigo do método BuildAllEscopos() quebrou.

RESUMO:
		---> nova instrução: SetVar().
		---> implementado um sistema de casting implicito, na classe de avaliação de expressões, [Eval].
		---> fixado imprecisão e erros no método Expressao.ExecuteFunction().
		---> fixado o loop infinito do método MatchSequencias(), e para sequencia id do loop infinito, retornou a valor correto.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.11:
		----> codificado instruções GetVar() e SetVar().
		----> método GetVar() retorna o valor da variável na pilha de objetos da classe OperadoresNativos.
		----> loop infinito no método ExtraiEXPRSS(), fixado, mas diversas modificações. testes, sucessamente, o código pode estar quebrado para outras sequencias id.
					---> mais a fixar: a instrução "if/else" não aparece no texto do metodo ToString().
					---> todas sequencias id do teste de instruções passou sem erros fatais.
					---> sequencia de instrução "if/else" não retorna corretamente o esperado. 
							---> falta outra sequencia id, para sem a instrução "else" e o bloco associado.
							---> codificado mais sequencias id, diferenciando a instrução "if" de "if/else"


					--> verificando, um bloco da instrução "if" não está sendo processado corretamente.
							---> fixado aparentemente, o código do escopo não é o código total, mas o código da sequencia id do bloco.
							---> quase lá, a expressão vinda do escopo folha não está sendo registrada na tabela de valores do escopo folha.
									---> verificando, a sequencia id do bloco é a própria expressão! aparecera como sequencia e não como expressão. Fixar isso.


RESUMO:
	----> codificado e implementado instruções Getters/Setters para variáveis não vetoriais.
           		-----> Getters retornam o valor na pilha de objetos, da classe OperadoresNativos.

	----> fixado o método ExtraiEXPRSS(), simplificando o código, que foi extraído da ferramenta refatoração da IDE, foi fixado o erro.
	----> várias modificações no método MatchSequencias(), o processamento de blocos foi fixado.

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.11:
	---> modificado o método RegrasHeuristicasExpressoes, para escolher se aceita dois tokens id em sequencia, como: ID ID.
		---> falha nos testes, o método ResumeExprss() não está funcionando adequadamente. O sinal de ponto e virgula não está sendo contado.
		---> modificado o método RegrasHeuristicasParaExtrairExpressoes(), para incluir o operador ponto-e-virgula na expressão.
					--->  fixou para expressões como: "ID ID = EXPRSS".
					---> para o caso de teste: "if", não está reconhecendo a instrução, e também a expressão de controle.

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.11:
  		---> build da instrução if/else está quase lá, há uma sequencia extra de bloco que está sobrando.
					----> recodificado a construção de blocos na instrução if/else, mais legível. mas aparece dois blocos, e o teste tem apenas um bloco.
									----> fixado, foi utilizado um método FindIndex que não é o recomendado para este trecho de código, substituido pelo método IndexOf().
									----> está havendo a construção de uma instrução extra, com código "codeBlock", que não estaria lá se não fosse o método BuildAllEscopos() também já fazia a adição da instrução resultante.
									---> planejamento da obtenção de instruções de blocos feita: instruções "if/else", "for", "while", obtém instruções no método BuildAllEscopos(),
										 adiciona as instruções encontradas para o bloco, e depois retira as instruções do bloco encontradas, da lista de instruções da VM.

		---> testar e fixar instruções if/else, for, while, para verificação da obtenção de blocos de instruções.
						---> teste instrução "if/else", falha na instrução do bloco, está com uma sequencia mapeada com indice errado.
						---> a falha está no método de resumir expressões. modificações no método MatchSequencias().
						---> visão mais clara do método ResumeExprss(): resume expressões com "ID e operadores" para "ID".
								
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.11:
		---> teste do método ResumeExprss() sem falhas fatais, e parece funcionar adequadamente.

		---> sem instruções redundantes, construção de bloco dentro da sequencia correta, só não registra bem a instrução dentro do bloco.
					--->investigando, a extração de blocos não está funcionando adequadamente, retornando null, e não extraindo o bloco.


		---> regressão para a versão sem erros no método RegrasHeuristicasParaExtrairExpressoes(), retirando o indice de começo da extração de blocos.
					---> modificações no método ResumeExprss(), com testes sucessamente para : "ID ID = ID".
					---> falha na obtenção da instrução "if/else", não foi registrado a instrução.
							---> o indice de começo da expressão estava em 0, e não na posição do tokens ponteiro, no método ResumeExprss(). No entanto o sistema insiste em mostrar a sequencia id currente a certa...
					---> com o indice de expressão corrigido, o sistema voltou a registrar a instruçao "if/else", mas a instruçção do bloco da instrução "if/else" do exemplo não está sendo processada.
					---> o escopo do bloco não estava setado para escopoFolha do escopo da instrução, por isso não reconhecia a variavel "i", que faz parte da instrução de bloco do exemplo.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.11:

		Atividades do dia:
		---> (feito parcialmente) verificar se a construção do bloco de instruções do teste "if/else" está sendo feito.
					----> está sendo construido, mas o escopo utilizado não reconhece a variavel dentro do bloco.
		---> (feito) investigar se a construção do bloco está sendo feito no método MatchSequencias().
					---> está sendo construido, os Build de instruções podem utilizar estes tokens de bloco.

		---> (feito) verificar se a instrução "return" está guardando o resultado da função, na pilha de objetos, na classe OperadoresNativos.
		---> planejar um meio de retirar o resultado de uma chamada de função, na instrução atribuição.
					(a codificar) ---> algoritmo: FazAChamadaDeFuncao(), retira o valor de retorno da pilha de Objetos da classe OperadoresNativos, e a associa à variável a ser atribuida.

	
		---> fixar o erro de não reconhecimento da variável dentro do bloco.
					---> a fixar, tentativa de obter instruções do bloco, resultou na não soma da instruções do bloco.
							---> a fixar, agora a instrução é reconhecida, mas as variaveis dentro da instrução não estão sendo reconhecidas.
							---> o problema está no reconhecimento do escopos pai, filhos. fixado, o escopo pai não estava setado.
							---> a expressão de atribuição do bloco da instrução está com registro de variável errados, e desnecessária.
	
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.11:

		---> fixar o método RegrasHeuristicasParaExtrairExpressoes(), lançou exceção de não inicialização do operador.
			---> fixado um dos casos de uso de extrair expressões, o indice de cumprimento da expressão estava incorreto. Mas não era o erro relatado.
			---> investigando, o erro está numa atribuição de uma expressão null. Mas ao fixar, as instruções não são construidas, nem a tabela de valores é atualizada.
							---> verificando as sequencias encontradas, os indices de métodos tratadores estão sendo retornados (verificar se é o indice tratador correto), mas a construção das instruções não estão sendo feitas.
							---> a fixar, o método ExtraiExpressoes() está quebrado, o método BuildEscopos() não está registrando as expressões da sequencia encontradas.
										---> FIXAR o método ExtraiExpressoes(). fixado, havia um erro no algoritmo de RegrasHeuristicasParaExtrairExpressoes().
							---> a verificar se "else" é termo-chave da linguagem. Verificado, é termo-chave.
							---> fixado  o método ExtrairExpressoes(), e o método atribuição, retornando tipo e nome de variavel, para atribuições simples, mas não para a instrução dentro do bloco, está registrando o nome, o tipo da variavel erradamente.
										---> construção do bloco, e associação do escopo do bloco, como escopo folha, feita sucessamente, apenas a atribuição, QUE NÃO TEM TIPO DENTRO DA EXPRESSÃO DE ATRIBUIÇÃO!.
										---> codificado o método BuildAtribuicao(), para conter atribuições de variáveis já inicializadas, como a atribuição: "x=x+1".
										---> teste para instrução "if" parcialmente sucessamente, está registrando um bloco a mais, talvez para complemento da instrução "else".
										

		---> (a codificar) algoritmo: FazAChamadaDeFuncao(), retira o valor de retorno da pilha de Objetos da classe OperadoresNativos, e a associa à variável a ser atribuida.
							---> codificado, o resultado da chamada de função é retornado na pilha de objetos.
							---> instrução de atribuição, que precisaria do resultado de uma função, na pilha de objetos, não é necessário.

	   ---> modificado o método ExecuteFunction(), para retornar um valor object, e dentro do método, o acesso do retorno do método é feito pela pilha de operadores.

	  ---> fixado o bloco a mais da instrução "if". Quase lá, está registrando uma atribuição errado para a instrução dentro do bloco, inicializando uma variável com nome "protected"..
					---> o escopo da instrução do bloco não está funcionando adequadamente, não registra como escopo pai quando tenta acessar a variável "i" um nivel de escopo acima.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 18.11:

		--> a fixar a atribuição incorreta para a instrução do bloco, de uma instrução if/else e instrução de atribuição.
					---> fixado! Havia um erro no método GetVariavel() da classe TabelaDeValores.
					---> fixado os erros na classe TabelaDeValores, para obtencao de nomes atraves do método Find().
		--> testes para instrução: "while", o termochave "while" não está sendo reconhecido como termo-chave da linguagem.
					---> fixado.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.11:
		---> fixar a validação de expressões, vital para expressões de controle, em "while", "if/else", "for".
				---> codificado método para validar os termos de uma expressão, se estão registrados. método: ValidaTermosExpressao().
		
		---> ante a quebra do código de MatchSequencias(), foi codificado um novo algoritmo para capturar sequencias mapeadas (método novo: MatchSequencias_3());
					---> fazer um backup do arquivo que contém o MatchSequencias(). (feito)
					---> substituir o método ResumeExpressao da classe ProcessadorID, para o novo algoritmo,
					ou compor um novo método MatchSequencias(), utilizando o novo método ResumeExpressao_3().
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.11:
		---> retrabalho, o método MatchSequencias() está com muitos erros, foi substituido por um método mais "natural".
					--->testes, erro na construção da instrução dos blocos, no teste para instrução "while".
						---> o método BuildAllEscopos() pode estar gerando indices de metodos tratadores errados (fixar).
						---> fixado parcialmente, mas para sequencia dentro do bloco não está reconhecendo: "i=i-1;", fixado, a sequencia tem variaveis não inicializadas "i".
						---> o método ResumeTodasExpressões não está funcionando muito bem, um erro em torno do operador ";".
						---> fixado para apenas parte do teste. Contagem +1 para token[x]==";".


		---> implementação de validação de termos de expressões, para instruções "for", "while","if/else".
					---> no teste no build da instrução "while", não ocorreu a mensagem de erro para a variável não inicializada.
					---> quase lá, faltando a operação correta para determinar a instrução do bloco no teste. fixado! A instrução "while" de teste sem erros.


		---> faltando duas instruções: construtor de operador unario e construto de operador binario.
________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.11:
			----> instruções if/else sob testes. fixado o bloco duplo, para o cenário de teste.
					---> validação de variáveis da expressão de controle da instrução "if/else", feita.

__________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.11:
			---> retrabalho para adequar a classe Expressão e classes filhas para conformidade de principios POO.
						---> verificação de construção de expressão ok. Expressão com um ponto-e-vírgula somente, fixado.

_______________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.11:

			---> continuando os testes para instruções. teste para instrução "for". falha no teste, não está reconhecendo o indice tratador de método de construção de instrução.
						---> a investigar o extrator de sequencias id, com o observado, o código todo do teste foi resumido em uma unica sequencia id.
						---> o método quebrado é o método ResumeTodasExprss(), não está funcionando adequadamente. Dificuldade que impede de avançar por causa dos indices e comprimentos das expressões a serem resumidos.
									---> adição de novos casos de uso para resumir expressões, no método ResumeExpressões(). testes inicial sucessamente.
													---> sequencias id testadas: ["while (id ) bloco"],   ["id id = id ;"], ["if (id) bloco"], e ["for (id id= id; id;  id) bloco"].




			---> codificado novamente o método polêmico MacthSequencias(), para usar o método ResumeTodasExprss(), que simplifica e muito o processo de identificador de sequencias mapeadas.
						---> sob testes.
			---> a testar, após a instrução "for": construção de operador unário e construtor de operador binário.
						---> a codificar a instrução de operador unario, e instrução de operador binário.
			---> opcional: completar o novo método Tokens.GetProducoes(), que usa as técnicas de processamento de sequencias, pela classe ProcessadorIDs.
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.11:
			---> codificado o novo método Tokens.GetProducoes(), faltando validações de semi-produções, e listagem de semi-produções.
			---> codificado as instruções de construção de operador binário e construção de operador unário.
			---> atualizado o método MatchSequencias, para comparar itens de expressões até o limite de itens de sequencia id já mapeado.
				---> atualizar as sequencias já mapeadas, para ir até o limite de itens constantes, não variantes.
						---> sequencias já mapeadas atualizadas, para cortar itens variantes (modificações em Chamada de Função e Chamada de Método).


			---> a testar a instrução "for". O interessante é que mesmo uma sequencia mapeada não presente, ao acrescentar o codigo chega até o método tratador correto....
						---> falha no teste, mas não na parte sendo testada, mas no método Expressao.ExtraiExpressoes(). fixado..
						---> registro de expressões da instrução "for" feito, escopo-filho construído, avisos de erros construído corretamente.

						---> mais falhas: o IP das instruções não é incrementado, e a expressão de atribuição da instrução "for" não registra o tipo da variável de instrução.



Código Modificado:
		Tokens.GetExpressoes_3();
		método MatchSequencias();
		método ResumeTodasExprss();
		classe Instruções (é preciso verificar os parâmetros passados na instrução).
		Funcao.ExecuteFunction().acrescimo da variáveis parâmetro, como variáveis locais, dentro da função.
		método EvalFunction modficado, para calcular como valores os parametros, não como valores de expressões associadas.
________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.11:
		---> fixar o problema do contador IP das instruções, que não é incrementado. fixado, a variável IP_instrucao guarda o endereço da instrucão, e é atualizada na construção da instrução, e serve para ordenar crescentemente as instruções.
				---> verificado e fixado o caso de blocos nas instruções, devem ser posteriores a instrução principal.

		---> fixar o problema da variavel de atribuição da instrução "for" não está registrando o tipo da variável da atribuição.
				--> fixado, o método ExtraiExpressoes() estava retirando um token a mai com List.RemoveRange().

		---> nova funcionalidade de instruções: codificado um método para expandir a lista de tipos de instrução, na classe Instrucao,
		seguindo o padrão de projeto [Command].
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.11:
		---> testes para instruções básicas: "while", "if/else", e novamente a instrução "for".
			---> teste para instrução "if/else":
				---> falha na instrução "if", parece que o método para encontrar sequencias iguais não está funcionando bem.fixado, teste sem erros fatais, mas no build da instrução if, há mensagem de erros de variaveis não definidas, e o bloco da instrução não está sendo construido. fixado, havia um erro de lógica booleana na avaliação da expressão de controle da instrução if.

			---> teste para instrução "while";
				---> testes sucessamente, mensagem de erro para variável de controle funcionando, construção do bloco da instrução funcinando.

			---> conferindo se as modificações não quebraram o código, houve uma falha na instrução "for", na variável instanciada dentro do bloco da instrução.

		
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.11:
---> a fixar: instanciação de variáveis dentro de blocos, com teste para instrução "for".
		---> a testar: novamente a instrução "for", e a construção e definição de funções.

		---> testes finais de instruções for e if com falhas. investigando, o código do método ResumeExprss() está quebrado, devido à modificação de inclusão do sinal de igual como definidor de expressões.
						---> método ResumeExprss fixado.
						---> fixado o método atribuição de variaveis (InstructionAtribution), origem do problema de não reconhecimento de variáveis de atribuição e de variáveis de escopo folhas (bloco).	
		---> testes para instruções "for" e "if" sucessamente.


----> um erro de conceito: as variáveis de atribuição de uma expressão não recebe seu valor no momento da atribuição.
			---> fixado para valores números, para objetos ou chamadas de função é preciso uma nova funcionalidade.

----> passando para Sprint Review, da Sprint Instruções da Linguagem.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.11:
		---> começo ne nova sprint.
			---> sprint backlog: 1- construir um programa a partir de vários arquivos de texto.
						---> codificado, aguardando testes.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.12:

		---> feitos:
				---> melhoria no método Classe.ToString(), para conter o nome da classe, os campos da classe, e os métodos da classe.
				---> método de leitura de classe, ainda no container CorpoTestes, mas que pode ser uma funcionalidade dentro da classe "Classe".
				---> retirado do ProcessadorID.CompilerEscopos() o código que constroe escopos de classes, pois estava entrando em loop infinito.
				---> modificado o método de getTokensEntreOperadores, para retirar o primeiro operador, e o ultimo operador, nas extremidades da lista de tokens.
				---> verifcado e fixado os métodos extratores de classes, propriedades, e métodos. testes sucessamente.

		---> a fazer:
				---> testar classe para construir programa a partir de vários arquivos.

		---> verificar os extratores OO, para construção de Escopos no método CompilerEscopos().
				---> testes para construir classes, extrair métodos, extrair propriedades, falha logica na construção das instruções do corpo do método.
							A lista de tokens está sendo inicializada com null, e é referenciada com este valor. fixado.
							A construção, devido a modificação no método GetTokensEntreOperadores(), falha na construção dos parâmetros da função, os cálculos ultrapassam a interface de parâmetros da função...
							Registro de métodos fixado, Registro de Propriedades não está funcionando muito bem, não registra as propriedades, e dentro do método
							de extração de propriedades, há o registro da classe da propriedade, o que não é da responsabilidade do método..

							---> a fixar: extrator de propriedades. fixado, apenas para apreender como o erro foi feito, não foi chamado com os tokens do codigo, mas com o proprio codigo.


_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.12:
			---> teste para classe de construção de programa a partir de varios arquivos.
				----> obtenção de dados dos arquivos esta funcionando, mas para construir os arquivos não está sendo feita,
				por quê? porque as classes não são compiladas pelo método ProcessadorID.CompileAllEscopos().
					---> é preciso fazer um método para compilar classes.
								-----> adicionado uma funcionalidade para compilar classes, dentro da classe CompilerFiles, e ProcessadorID.
				----> testes para compilar arquivos, falha ao tentar compilar funções: definições de função não está registrando a instrução de definição de funções.
				---> fixado, a instrução "define function" é vazia, pois é construida na compilação do programa.
		   ---> fixar os nomes dos métodos de classe para métodos longos. fixado.

		   ---> a fazer:
					---> não chamar diretamente o método CompileAllEscopos(), mas sim o método CompilaClasses()... coisas estranhas podem acontecer
					se chamar o método CompilaClasses(), antes ou depois de CompilaAllEscopos().


_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.12:
			--> o registro das instruções passa para a classe ProcessadorID.
					---> falha no método CompileClasses, que não está configurado para adicionar as instruções de classes.
							---> as classes estão sendo registradas, mas as instruções da classe estão desaparecidos.
							---> planejamento para como adquirir as instruções dos métodos de uma classe.
									--> verificando, as instruções de métodos são passadas, mas as instruções de propriedades não.
									--> as instruções de atribuição não estavam sendo registradas, no ProcessadorID, fixado.
									--> falta: a retirada das instruções de atribuição, nos extratoresOO (método ExtraiPropriedades()).
											---> implementado, as instruções de atribuição são retiradas da tabela de valores, e são atribuidas à instrução de atribuição.

			---> testar a extração de classes, para verificar se as instruções de atribuição estão registradas nas propriedades de classe, e retiradas da tabela de valores.



			---> Gerenciamento de Mudanças: as tabelas de valores teriam que ter um objeto na classe Classe?
							---> mudança já implementada: o escopo do processamento de classe é guardado numa variável Escopo, que também contém uma variável TabelaDeValores.

			--> com a mudança de foco para a classe Classe ter um escopo próprio, não é necessário retirar do registro da tabela,as propriedades e métodos encontrados.

			--> com a inclusão de um campo do tipo [Instrucao] dentro de propriedades e métodos, não é preciso tomar cuidado com inclusões de instruções.

			--> fixado a extração de instruções do corpo de uma função, não estava registrando, nem fazendo processamento.

			---> a fazer: 
					1- uma varredura entre instruções de atribuição e propriedades para registrar as instruções, para a VM.
					2- criação de uma instrução "classe", para definição de uma classe.
					3- criação de um entry-point para começo do programa na VM.
__________________________________________________________________________________________________________________________________________________
Daily Scrum 04.12:
			---> eliminando redudâncias na classe ExtratorOO, para conter apenas um tokens da classe e um escopo da classe.

			---> a fazer:

					----> verificar se as instruções estão sendo feitas, e guardadas nos métodos e propriedades, e depois adicionadas no ProgramVM.
					1- uma varredura entre instruções de atribuição e propriedades para registrar as instruções, para a VM.
					2- criação de uma instrução "classe", para definição de uma classe.
					3- criação de um entry-point para começo do programa na VM. (feito)

		o que impede de realizar sua tarefa hoje?
			----> planejamento mais clarro da instrução "classe": seria a extração dos tokens, escopo e instruções da classe?
			----> (resolvido) o entry point teria que fazer uma varredura pelas classes, para encontrar o método do "ponto de entrada do programa":
_____________________________________________________________________________________________________________________________________________________
Daily Scrum 08.12:

	 ---> fixado o código para obter instruções de atribuição de variáveis/métodos, e código para definição de funções/métodos. ok,
	 mas:
		---> testes para composicao do escopo da classe, falha no método: ObtemEscopoDaClasse(Escopo escopo). 
		fixado, testes falha, sem erros fatais, mas não está registrando o método corretamente, em expressões está o cabeçalho do método (ex: int funcaoB()), ou melhor, a função está dentro das expressões, então ok.
		o registro das instruções do corpo da função estão registradas,
		mas o registro de atribuições a variável/método não está funcionando bem. verificado, está registrando e funcionando também...


	---> uma discussão polêmica é se as instruções de definição de operador binário e definição de operador unário precisam ter uma instrução.
		---> verificar se cada handler de compilacao tem uma instrução a ser adicionada no programa com VM.


		----> O que falta de atividades deste dia:
				---> continuar testes, com corpo de método com instruções "for","while", "if/else".
						----> instrução "for": a instrução da atribuição da variável de controle está vindo primeiro que a instrução "for".
									----> erro conceitual: a atribuição e definição da variável de controle deve ser tratada como expressão, que será avaliada quando a  instrução "for" for executada. fixado.
						----> instrução "if/else": a construção do bloco da instrução "if" não está funcionando muito bem.
									---> uma atenção: a variável parâmetro da função não está podendo ser validada dentro do bloco da instrução. FIXAR.
									---> fixar também: a instrução dentro do bloco do método está sendo validada duas vezes, uma na construção do bloco do método, que não constroi o bloco da instrução dentro do bloco do método, e outra na sequencia de instruções, sem o processamento do método.
													---> investigando, o método ExtraiMetodo está com o escopo da classe, deveria ser o escopo do método. Uma solução seria não chamar o processamento de todos métodos.
															--> inacreditável! O escopo da classe já tinha o método registrado, não precisando processamento de todos escopos....

						----> modificações no método Tokens.GetProducoes() não está mais reconhecendo sequencias id;  FIXAR.
									---> investigando, as instruções vinda do processamento do bloco não estão sendo tratadas. é porque os parâmetros da função não estavam registrados no escopo da função, resultando em um erro de não definição de variável parâmetro. fixado.

						----> processamento do bloco não está trabalhando adequadamente. fixado.


		-
*****************************************************************************************************************************************
		---> resumo do dia:
				----> métodos e propriedades de classes sendo registrados corretamente.
				----> verificado construção de instruções "for", "if/else".
				----> processamento de blocos de instruções funcionando adequadamente.
				----> modificação no método Tokens.GetProducoes() quebrou o código, não reconhece sequencias id. Talvez a obtenção da sequencia id, para registro como produção, o que é uma dificuldade, pois sequencia deixou de herdar de produção. fazer um planejamento do caso.

				(INSIGHT) de otimização:
				----> uma possível mudança: depois de um primeiro processamento, guardar em cache os endereços das variáveis, pois há um cálculo extra no processamento de localização da variável, tendo que fazer varredura em 1,2, ou 3 níveis de escopo...

				---> fim do dia: o que falta?
						1.----> verificação da construção da instrução "while".
						2.----> codificar instruções para operador binário, operador unário, definição de classe...


*******************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.12:
				----> fixado erro no handler de definição de método/função.
				----> fixado um erro para correção da tabela de valores, para conter nomes longos para definir propriedades.
				----> fixado um erro para correção da tabela de valores, para conter nomes longos para definir métodos.
				----> a fixar o problema de acesso aos parâmetros da função, pelo corpo da função.
							---> há um problema conceitual: os parâmetros da função não possuem o nome longo. fixado.
							---> não está registrando instruções de dentro da instrução definiçao de função/método. fixado, as instruções do corpo da função ficam de fora do fluxo principal de instruções, estão dentro da função definida.
				----> fixado o erro de não registrar o acessor das propriedades extraidas.

						
Atividades do dia:						
			1.----> (feito) verificação da construção da instrução "while". verificado, construção sucessamente.


			2.----> (feito) codificar instruções para operador binário, operador unário, definição de classe...
					----> (feito) para compilar uma definição de classe, é preciso modificar o método CompileAllEscopos(), para tratar uma classe por vez, extraindo dos tokens da classe, dos tokens do método.
					----> (fixado) modificação do método de extrair uma classe, quebrou o código.
								---> constatado o erro, mas o sistema insiste em tokens da classe como os tokens do corpo da classe. fixado, os tokens consumidos não eram da classe, mas tokens da classe extratorOO.



Algum impedimento para fazer as atividades do dia?
			----> como construir instruções de definição de operador binário e operador unário. implementado um padrão em expressões contendo os dados a serem lidos na instrução OperadorBinario, e instrução OperadorUnario.
						----> teste codificado, foi preciso refatorar a avaliação de função, para obter as funções implementadas na linguagem base (C sharp).


Proposta para nova funcionalidade na classe Funcao: avaliação de funções com parâmetros expressoes.
			----> funcionalidade esperada, permite maior flexibilidade na avaliação de funções.

**********************************************************************************************************************************************************************************************************************************
----> resumo do dia:
			---> fixado erros de extração de métodos e propriedades, fazia construção de escopos para extrair métodos e propriedades, e que já haviam ser registradas na tabela de valores da classe, que é chamada uma única vez.
			---> correção de nomes de propriedades e métodos para nomes longos (acréscimo do nome da classe a qual pertence o método e propriedade);
			---> clareado como o algoritmo registra instruções do corpo de um método, ficam fora do fluxo principal de instruções, estão armazenadas na função.
			---> refatorado e fixado a classe Funcao, com nova funcionalidade de avaliação de função com parâmetros expressão.
			---> a aguardar a execução do teste para definição de operadores.
***********************************************************************************************************************************************************************************************************************************
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.12:
		----> Atividades do dia:
				----> (feito) rodar o teste para operadores unarios e binarios.
						---> testes operadores binarios:
								---> falha, não está reconhecendo a sequencia id da construção do operador. corrigido, o tokens "metodo" não estava incluido nos termos-chave, pois a mudança da definição de operador foi modificada recentemente. fixado.
								---> falha, não está reconhecendo a classe "int", no handler do operador binario. fixado, modificação também no repositorio de classes, o escopo do processamento pode ter sido reinicilizado após a construçao dos operadores.
						---> construção de operadores unarios e binarios operacional!			

				----> (feito) rodar o teste para a instrução "chamadasDeFunçao".
						---> codificado teste para chamadas de funcao.
								---> operacional, a chamada de função gera uma instrução "caller of function", conferido no programa da VM. (a conferir, nem todos dados estão aparecendo, apesar do texto descritivo esteja correto.)
											--> o método  "Expressao.Instance.ExtraiExpressoes()" está retornando apenas a primeira expressão. método RegrasHeuristicasParaExpressoes() quebrou, pois no final do método foi codificado que constituiria uma nova expressaoa com os tokens restantes.
							(a fazer teste) --> planejamento para um novo método de ExtrairExpressoes. CODIFICADO NOVO MÉTODO para extrair expressões, aguardando testes.


				----> (a fazer) planejamento de variáveis estáticas: como acessar? são lista estática numa classe? É preciso modificar métodos na tabela de valores?
							----> utiliza um marcado na variavel constando como "estatica/naoEstatica", e reescrever o handler para incluir um nome da classe como item de identificador da variavel, também.

				----> (a fazer) planejamento da instrução:"casesOfUse": permitira que tipo de dados? "int", "float", "char","string", e alguma classe que sobrescreva o método "Equals"?

				----> (feito) como acessar variaveis vetores? Métodos como GetVariavelVetor deve ter indices de acesso?
								---> planejado e implantado uma nova classe de variavelVetor, que contem uma lista de variavelVetor, e um array de valores para cada variavelVetor.

Algum impedimento para fazer as atividades do dia?
			----> clareza no planejamento das variáveis estáticas.			
			----> clareza no acesso e implantação de variáveis vetor. (a conferir).
							---> testes para construcao de um vetor multi-dimensional feito sucessamente. Tem-se agora um vetor que pode ser matriz, aumentando as possibilidades da linguagem!
							---> teste para get/set de elemento multi-dimensional feito sucessamente!
							---> modificacao na classe EvalExpression para calculo de vetores multi-dimensionais.

							---> classe VariavelVetorMultiDimencional operacional. Setter/Getter sucessamente, construção sucessamente;
										----> para cada dimensão, há um valor dimensional diferente (ou iguagl se o desenvolvedor construir a matriz de indices).
										----> falha em conseguir dimensões de diferentes entre si... fixado, o algoritmo é recursivo, e precisou mais um parametro, que é a variável de parada.
								
************************************************************************************************************************************************************************************************************************
Resumo do dia:
			----> modificado a classe VariavelVetor, para conter VariavelVetor multidimensional!. Método Set/Get (ok), Constructor (ok), EvalExpression para vetores multidimensionais (ok).
			----> testes e fixo construção de operadores binarios e operadores unarios.

*************************************************************************************************************************************************************************************************************************
O que faltou:
	----> teste para novo extrator de expressoes.
	----> planejamento para a instrução "caseOfUse".
	----> implantação das variáveis estáticas;
				

_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 11.12:

	Atividades do dia:
	----> implantação de variáveis estáticas.
			---> (feito) criação de um campo bool para setar se a variável é estatica.
			---> (feito) adição sem produção do termo-chave "static";
						---> fixado e adição de variáveis estáticas, no método handler de DefiniçãoVariavel().
						---> a fazer:
								----> (feito) excluir da lista de propriedades as estaticas que é passada para uma nova instância de um objeto.
								----> (não viável,aumenta complexidade da codificacao):acrescentar as variaveis estáticas como uma lista de propriedades estaticas na classe "Classe". 
								----> (feito)---->na tabela de valores, acrescentar ao nome interno da variavel o termo: "static.", para diferenciar das propriedades comuns dentro do processamento de variáveis.
								----> (feito)----> métodos da classe TabelaDeValores para conter variáveis estáticas.

	----> (feito) testes e fixados o novo método de extração de expressões.
				----> fixado, ficando a polêmica se dois ids seguidos devem estar numa mesma expressão. modificações feitas.


	----> (feito) testes para instrução "chamada de função" feito com falhas, entra em overflow.
				----> corrigido, para uma expressao com um só token de uma expressão função, não precisava extrair parametros.
				----> fixado os erros, mas está retornando em dobro a definição da função. fixado, uma instrução em duplicidade estava no handler de definicao da funcao.
				----> handler para "chamada de função" operacional! É recomendado mais testes com novos cenários.

**********************************************************************************************************************************************************************************************************
Resumo do dia:
		---> implementação de variáveis estáticas, que não são copiadas para instanciação de objeto. modifcações na classe Objeto, classe TabelaDeValores. Aguardando testes.
		---> novo método de extração de expressões, mais menor complexidade, porém robusto. testes sucessamente.
		---> testes sucessamente para instrução chamada de função.
		---> método para construção de escopos transferido para ProcessadorDeID.Compile().
***********************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.12:

---> Atividades do dia:
			---> testar o uso de variaveis estaticas.
						---> a codificar no método DefinicaoVariavel(), o uso de propriedades estáticas. codificado.
			---> planejamento da instrução "casesOfUse".

	----> implantado o novo método Tokens.GetProducoes(), teste pronto, aguardando rodagem do teste.
			----> falha teste, está entrando em loop infinito. verificando, o método ResumeExpressoes() está em loop infinito.
			----> fixado o método ResumeExpressoes(), mas há falha na lógica do algoritmo: está indefinido a produção encontrada no match sequencias.
			----> fixado o algoritmo, codificado um método para encontrar tokens entre [tokensAProcurar] e [tokensProducaoMaquinaDeEstados], aguardando testes.
			----> falha na construcao de producoes resumidas. falha no método ResumeTokens(), deveria resumir se há sequencia de dois ids seguidos.. o segundo token da sequencia de dois id seguidos não está sendo retirados.
			----> fixado, registro de producoes com termos-chave (correto), producoes com sequencias id, como "int k=0;" (correto), mas há uma sequencia a mais entre as duas producoes validadas, com conteudo "ID".
			----> codificar talvez a contagem na malha principal não esteja sendo atualizado adequadamente.
						----> verificando, o método está funcionando adequadamente! para o cenario de teste, que contem apenas uma instrução da linguagem orquidea.
						----> a codificar a adicao de producao com sequencias id começando com ID.


Resumo do dia:
		----> codificado o uso de variáveis estáticas.
		----> fixado e recodificado o método GetProducoes(), que retorna a producao correta, se o primeiro token for um termo-chave,
			a lista de semi-producoes e sequencias id não estão sendo registrados.

___________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.12:
		-------> a codificar o método Tokens.GetProducoes, com novas funcionalidades.(processamento de semi-producoes, de tokens de blocos, e de sequencias id sem producao na linguagem).
				----> codificando para obter semi-producoes, faltando o processamento recursivo para cada semi-producoes.
				----> codigo incompleto, faltando especificar os tokens entre dois termos-chave.
							----> falha no método de obter semi-producoes. 
									-----> fixado, as semi-produções estão sendo calculadas, 
							mas a sequencia de entrada não é a lista de tokens da produção, mas da sequencia inteira, incluido blocos de tokens.
									-----> fixado, apenas termos-chave da produção são verificados, mas há ainda erro na obtencao de uma semi-producao extra.
									-----> fixado, obtencao de semi-producoes feitas sucessamente.
							----> é recomendado mais testes com outras produções da linguagem.

		-------> a implantar outras funcionalidades, o processamento de blocos, e o processamento de sequencias id que não possuem producoes da linguagem.
							-----> (feito) producoes em tokens de um bloco, codificado, aguardando testes.
							-----> (feito) produções de sequencia já feito, aguardando testes.
											---> produções de bloco dentro de uma sequencia, aguardando testes.
___________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.12:
			----> fixado o método Tokens.GetProducoes().
			----> inclusão de novos operadores na classe de definição do tipo de retorno do operador.
			----> completado métodos GetOperadores(), que retornavam apenas os operadores da linguagem vindo do arquivo XML. Agora, retorna também operadores das classes registradas.
			----> teste para uso de variaveis estaticas. 
						----> testes já codificados. fixado, testes sucessamente.
							----> uma pergunta interessante é que a variável estática deve ter total visibilidade, por que não colocar na definição da classe, se for propriedade da classe?
										---> mudança aprovada, acrescentado na classe Classe uma lista de variáveis estáticas, populada no ProcessadorDeID.DefinicaoVariavel(). testes sucessamente.

			----> constatação de que a classe PosicaoECodigo não estava funcionando muito bem, eliminação de construtores não utilizados, e fixado o cálculo de obtenção da coluna da posição da lista de tokens. testes sucessamente.

			---->  planejamento da instrução:"casesOfUse": permitira que tipo de dados? "int", "float", "char","string", e alguma classe que sobrescreva o método "Equals"?


**********************************************************************************************************************************************************************************************************
Resumo do dia:
				------> funcionalidade de obtencao de semi-producoes feito.
				------> funcionalidade de obtencao de producoes entre blocos.
				------> funcionalidade de obtencao de producoes que são sequencias.
				------> registro de classes estáticas. (manipulação de variáveis estáticas feitos na classe Objeto).
				------> extensão do método GetOperadores(), populado com operadores das classes nativas. 
				------> fixado erros na classe PosicaoECodigo.

				funcionalidades de Tokens.GetProducoes():
					1- de tokens com termos-chave (produocoes mapeadas no arquivo XML de produções).
					2- processamento de semi-producoes;
					3- de tokens de blocos;
					4- de sequencias id sem producao na linguagem.
**********************************************************************************************************************************************************************************************************
_______________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.12:

		-----> (feito) planejamento da instrução "casesOfUse".

					planejamento: 

					----> compoe a instrucao caseOfUses: 
							--> I-expressoes contém: 
            					--> nome da variável principal,
								--> expressões de operação condificional entre a variavel principal e a variavel do case currente..

							--> II- blocos contém: 
								--> blocos de instrução, cada bloco para um case.




		-----> codificado:
					---> método handler da instrução "casesOfUse" de compilação.
					---> método de avaliação da instrução "casesOfUse" da VM.


	-----> quais impedimentos para as atividades serem feitas hoje?
		   ----> como criar uma instrucao que abranje a variavel principal, e os blocos de instrução?
					----> a variavel principal é armazenada na lista de expressão.


**********************************************************************************************************************************************************************************************************************************
Resumo do dia:
		----> planejamento da instrução "casesOfUse".
		----> codificação do método handler de compilação da instrução "casesOfUse".
		----> codificação do método de avaliação da instrução "casesOfUse", na VM.

**********************************************************************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 15.12:
		----> a fazer: teste para a instrução "casesOfUse".
					---> falha, os tokens "{" e "}" estão sendo como termos-chave. modificado os termo-chave "{" e "}" para "(" e ")".
					---> testes, reconhecendo a sequencia, mas o método handler não compila a instrução. fixado, mas o handler não está funcionando muito bem: os blocos e as expressões não estão sendo construidos.
							----> fixado, o calculo das listas de tokens case foi fixado.
							----> O processador de ids não está construindo instruções dos blocos de cases. fixado, a lista de tokens do case estava incluindo o cabeçalho.
									----> a fixar o método ResumeTodasExprss(), não está contando os IDs seguidos. Verificando, não está resumindo sequencias id.
												----> os atalhos de BreakPoint não estão funcionando, é uma falha do sistema, além do desenvolvimento do projeto.
									----> fixado, no método MatchSequencias(), faltou resumir as sequencias ja mapeadas. 

		----> mais testes, com constantes strings como variavel case: falha, o formato de string com aspas não está adequado. fixado, o uso de aspas para strings não estava definida corretamente.

***********************************************************************************************************************************************************************************************************************************
Resumo do dia:
		----> codificado cenario de teste para a instrução de "casesOfUse".
		----> fixado e testado sucessamente o handler da compilação da instrução "casesOfUse", comporta variaveis, strings, numeros ints e floats como variáveis case.
		----> escolha de 1 método entre 2 de handlers de compilação da instrução "BuildDefinicaoDeVariavel".
************************************************************************************************************************************************************************************************************************************
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 16.12:

		----> inicio de uma serie de programas com instrucoes do orquidea.
					---> programa 1 sem erros fatais, mas parece que não está rodando as instruções orquidea, nenhum valor de saída foi produzido....
									---> modificação na classe "ProgramaVM", a lista de instruções não é mais estática. porem pode quebrar o codigo.
									---> codificado um método no processador de ids simplificado, automatiza todos dados, menos a lista do codigo a ser compilado e executado. 

					---> avaliacao de numeros para variaveis certo, porem para operação com variaveis está armazenando valores nullos.
									---> instrucao atribuicao equivocado, nao estava atribuindo o valor da expressao de atribuicao,à variavel a receber a atribuicao.
					---> fixado, mas há falha na definição de função que realiza os cálculos, problema de referências, em que um operador se sobrepõe a outro operador.
									---> a falha está no cálculo do Operador, no construtor da classe Expressao. fixado, mas há falha também no método PosOrdem(), que não está retornando o operador.
									---> fixado o método PosOrdem(), não estava reconhecendo operadores binarios e unarios.
					----> cenário teste programa 1 sem erros fatais, e com resultado exato.

**********************************************************************************************************************************************************************************
Resumo do dia:
		---> codificacao de um método para cenarios de testes com instruções orquidea.
		---> cenario 1, com atribuicao e soma de variaveis, feitas, fixados, sucessamente.
					---> sem erros fatais, desde o inicio, verificou-se imprecisões no uso de operadores, constituindo modelagem falha, pois não havia reconhecimento de operadores binarios e unarios, o que levou modificacoes no modo de se obter operadores.
**********************************************************************************************************************************************************************************
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.12:

	----> Atividades do dia:
			----> continuar com novos cenários de teste para instruções.

			----> cenário de teste 2 feito, sucessamente.

			----> cenário de teste 3, chamada de funcao, falha por que há duas sequencias com os mesmos elementos: definicaoDeFuncao, e chamadaDeFuncao.
						----> tentativa de fixar, mas há um problema nas sequencias mapeadas e mapeado, foi preciso ajustar o método ResumeAllExprss(), o que resultou na primeira sequencia correta, mas as seguintes falham.
						----> o codigo quebrou,o ResumeExpss() é viável para uma sequencia, e inviavel para outra sequencia.
									----> fixado , mas uma sequencia de chamada a função com atribuicao resultou em falha.talvez seja preciso quebrar em 2 a sequencia de chamada, na posicao do token "=".

						----> uma solução seria computar uma sequencia como se fosse uma expressão, se todos tokens forem de uma sequencia de expressao, retornar um codigo para DefinicaoVariavelEAtribuicao.
									----> o indice da expressao de atribuicao está errado na sua concepção de busca...
											---> fixado as soluções "aproximativas" de sequencias, mas continua sem definição de expressoes complexas para o método MatchSequencias(), 
												 por causa da dificuldade de determinar o indice de uma sequencia mapeada de atribuição. fixado..


						---> solução de fazer um hook no metodo DefinicaoDeFuncao(), para extrair os tokens consumidos na instrucao, falha.
						---> solução de trazer os tokens consumidos no método CompileEscopos() para o escopo da classe, não do método, fixado,
					
						----> mas a de uma expressão complexa, com variáveis e chamada de função, continua sem os tokens corretos para calculo.
							 Por incrivel que pareça, a solução do processamento dos tokens do corpo da função, resulta nos tokens a modificar, sem os operadores de bloco.
							 E ainda por cima, o match de sequencias devolve um indice totalmente fora de questão, o sistema teima em pertubar a paz alheia.
							 desculpa, o indice do handler estava sendo calculado com um codigo antigo, sem a última modificação para expressão complexa.
					
					ok!, aceitou a sequencia complexa como uma instrução de atribuição,
					mas o programa rodando, com as instruções da linguagem, gera exceção. Mas também, a funcaoB não foi definida no codigo do cenario de teste, o que pode ter causado a exceção.
								
								
								------> registro da função certa, instrução do corpo da funcao certa. instrução de expressão complexa registrada como atribuição e definição de variável.
								------> modificações no código não afetou outros cenários de teste. 

****************************************************************************************************************************************************************************************************************
resumo do dia:
	---> cenario de teste de expressão de várias variáveis, sucessamente.

	---> para o próximo cenário, houve problemas em sequencia desconhecida, uma combinação de definição de variável com chamada de função, o que dificultou o cenario rodar sucessamente.
			----> para sequencia de expressão complexa (com atribuição e definição de variável com chamada de função), foi atribuida como uma definição de variável, e só.			

	---> cenario de testes anteriores ao cenario de teste de expressão complexa, não quebraram com as modificações para atender o cenário de expressão complexa.

****************************************************************************************************************************************************************************************************************
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.12:


	Atividades do dia:
		-----> acrescentar no build de definição de atribuicao de variavel, o processamento de chamadas de função (falha).
		-----> testar o cenario de expressão complexa (falha).
		-----> planejamento maior para instanciação e manipulação de objetos, especialmente construtores. (a fazer).
	

	Impedimentos, dificuldades das atividades do dia:
		----> método eficaz para extrair chamadas de função.
				----> verificando o processamento do método Expressao.ExtraiExpressoes(), não está reconhecendo expressões que são chamadas de funções.

					----> codificando para o construtor da classe Expressao extrair chamadas de função.
					----> polêmica: a definição de uma função deve ter instrução na VM? Não... (tanto foi que a instrução de definição de função na VM está vazio).
					----> o problema está no método Expressao.ExtraiExpressoes().
								----> recodificado, continha muitos erros de lógica, retirou no entanto a distinção de token parenteses operador de expressão e delimitador de chamadas de função.
								----> codificar a distinção entre operador de expressão, e definidor de chamada de função. verificando o código, já há previsão para um parenteses abre, como delimitador de uma chamada de função.
								----> falha nos testes para método Expressao.ExtraiExpressoes(), não está acrescentando parenteses na expressão a construir.

		----> visão mais clara de objetos, construcao de objetos.
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.12:

		----> atividades do dia, devagar que é Sábado, deve-se respeitar o periodo de descanso (Metodologia Agil).
				---> solução encontrada para expressões complexas: um Resumidor para chamadas de função!
				---> codificado a solução encontrada.Retorado os métodos Resume, para implantar um parser de tokens, eliminando cálculos com muitos indices se repitindo. melhora a legebilidade do código também.
				---> há um erro nos métodos resumeExprss: não está resumindo operadores.
							----> ante a muitos métodos para resumir expressões, foi unificado para um único método de Resumo, facilitando modificações, e evitar erros de modificação num método e quebrar outros métodos de resumo.
							----> a testar o método resume. fixado, testes sucessamente. Agora temos um único método de ResumirExpressoes(), e que também processa chamadas de função registrada, justamento o problema do Daily Scrum anterior..
				----> o que tinha que codificar era muito simples: resumir para id se for (id, operador,numero, e chamada de funcao), exceto tokens participantes do mapeamento de sequencias ids!
							----> cuidar mais seriamente do planejamento dos algoritmos, principalmente com indices de listas e vetores...

		---> mudança necessária: toda vez que registrar um operador, atualizar os operadores obtidos no método da linguagem .GetOperadores(), filtrando se já houver o nome do operador.
							----> codificado, com um mínimo de modificações. testado, sem loops infinitos.


		---> Atividades para sábado e domingo, mas devagar e manter descanso:
				-----> testar o construtor de expressao, no cenario de uma expressao com codigo composto de chamada de funcao. testes, sucessamente.
				-----> (falha) uma parte da classe Expressao é também o método ExtraiExpressoes(), que está falhando em constituir elementos de uma chamada de expressão.
							----> ultima modifcação do dia, fixando a obtenção de chamadas de funções na malha principal de tokens.

				-----> acrescentar no build de definição de atribuicao de variavel, o processamento de chamadas de função.
				-----> testar o cenario de expressão complexa. Com o novo método ResumeExpressoes(), o processamento sai liso...
				-----> planejamento maior para instanciação e manipulação de objetos, especialmente construtores.

*************************************************************************************************************************************************************************************************************
Resumo do Sábado:
	---> unificado todos método ResumeExpressao, testes sucessamente para o método unificado ResumeExprss.
	---> modificação do código do construtor de expressao, para compor chamadas de expressão, testes sucessamente.
	---> modificação nos construtores da classe Operador, para adicionar o operador construido, na lista de operadores da linguagem. testes, sem loops infinitos (modificacoes na construção da linguagem eventualmente geram loops infinitos).

	---> inicio dos testes para o método ExtraiExpressoes().

*************************************************************************************************************************************************************************************************************
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum domingo:
	---> recodificado o método Expressao.ExtraiExpressoes(), estava confuso, dificil legebilidade.

_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.12:

----> Atividades do dia:
	----> testes para o método Expressao.ExtraiExpressoes().

	---> testes, fixados, para o método Expressao.ExtraiExpressoes(), extraiu uma expressão complexa.
				----> verificando o código, uma análise é que o método ExtraiExpressoes() não conseguira extrair expressões com mais de uma chamada de função, exemplo: "a+funcaoA()+b+ funcaoB(d)", o que 
				      precisa ser fixado.
					  tentativa de extrair expressões duplamente complexas, falha, falta um pouco de planejamento.
					  ---> recodificação, retrabalho, para tornar mais robusto o método ExtraiExpressoes(). aguardando testes.
					  ---> testes sucessamente.

				----> novo teste, com duas funcoes(), na lista de tokens, falha, a funcao Parcial não está funcionando muito bem.
							----> quase lá para expressões complexas com dois tokens de funcões. fixado, teste para expressão composta com dois nomes de funções esta funcionando,
								 mas o cenario de teste de expressao complexa com 1 nome de funcao, quebrou..


	----> O PLANEJAMENTO DE UM ALGORITMO É ESSENCIAL, ESCREVER EM UM ARQUIVO TEXTO O PASSO-A-PASSO, A RECEITA DO BOLO, PREVINE MUITO TEMPO DESPERDIÇADO.

		----> retrabalho para o método Expressao.ExtraiExpressoes(), com resultados parciais: para expressoes com 2 nomes de função, o método trabalha bem, mas
		para expressão com 1 nome de função, quebrou. fixado, para dois cenarios de testes com expressoes complexas, o codigo passou.

		----> um pouquinho de atenção na escrita dos cenarios, no teste para expressões complexas, ficou faltando um token ponto-e-virgula no final do codigo, ou seja, o código não estava correto para processamento...

Mais Atividades do dia:
		-----> acrescentar no build de definição de atribuicao de variavel, o processamento de chamadas de função.
		-----> planejamento maior para instanciação e manipulação de objetos, especialmente construtores.

********************************************************************************************************************************************************************************************************************
Resumo do Dia:
		----> escrita de 3 cenários de teste para expressões, com o método Expressao.ExtraiExpressoes(), sucessamente testados.
		----> inicio cenario teste [definiçao de variável com atribuição de expressão complexa], fixado o método ResumeExpressoes().

********************************************************************************************************************************************************************************************************************

_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.12:

		----> modificações, sem quebrar o código, no método ResumeExpressoes(), tornando menos tolerável a erros.
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.12:

Atividades do dia:
		----> testar método ExtraiExpressoes().
		----> testar o cenario de definicao de variavel com expressão complexa.

		----> refatorado o método ExtraiExpressoes, retirando a expressão parcial, que deixava o método muito complexo e sujeito a erros. testes sucessamente.
		----> codificado novamente métodos muito lentos da classe UmaLinguagemComputacional.

		---> testes para o cenario de definicao de variavel com expressão complexa, falha, o método MatchSequencias() não está retornando o valor esperado.
					----> é preciso modificar o método ResumeAllExpressoes(), pois a sequencia de ids seguidas não está muito adequado.
					----> ainda muito lento, é preciso refatorar mais os método da classe UmaLinguagemComputacional.
					----> teste para esse cenário, sem erros fatais.

_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.12:
		----> refatorado e fixado o método ResumeExpresoes(), estava de difícil leitura, e sujeito a erros.
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.12:
		----> continuando o refatoramento e codificado de correção, do método ResumeExpressoes().
		----> a testar o novo método ResumeExpressoes().
		----> método ResumeExpressoes() estava muito complicado com o uso de um parser de tokens, tirava a simplicidade, e preenchia com erros. Retrabalho para codificar o método
		sem uso de parser de tokens).
				----> simplificado mais ainda, o método tornava-se confuso com uma lista de tokens de retorno da função, a lista de tokens de entrada é a lista a ser processada.


_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.12:

	Atividades do Dia:
			----> testes com  o método ResumeExpressoes(), modificado na daily scrum anterior, falha, o algoritmo está pulando tokens, e a retirada da chamada de funcao não está funcionando muito bem.
					---> fazer um algoritmo utilizando indices, não é fácil...., fixado.
					---> recomendável mais testes.
								----> cenario 1: expressão complexa, com ids e chamadas de funçao. testado sucessamente.
								----> cenario 2: expressão simples, mas com numeros para termos da expressao de atribuicao. testado sucessamente.
						---> algoritmo a completar: reconhecimento de termos-chave como tokensNaoResumiveis. codificado, testes sucessamente.


		----> avaliar o cenario teste [definiçao de variável com atribuição de expressão complexa].
						---> o sistema reconheceu a sequenciaID, mas o build de definições de variáveis está quebrado, não está sendo contabilizado corretamento os tokens consumidos no build.
								---> investigando, constatou-se que a lista de tokens resumidos é feito pelo método ResumeExpressoes(), o que não está correto. a fixar, retirando a lista de resumidos do método CompileEscopos().
									 ---> retirado a lista de tokens resumidos no método CompileEscopos(), registro de variável ok, MatchSequencias() ok, ResumoExpressoes() ok. Falta verificar se a expressão de atribuição de variáveis está sendo calculada corretamente. Verificando, Expressao de atribuicao da variável ok.


		----> verificar a  instanciação e manipulação de objetos, e especialmente construtores. (após a implementação da classe Matriz, que estava sendo requisitada no Sprint Backlog currente).

		----> implementação da classe matriz: como uma classe da linguagem orquidea, ou implementação extra como tipo de variável.
				---> reuso de uma classe de matriz, vindo do repositorio de reuso.

________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.12:


	Impedimentos para executar as atividades:
				---> visão maior de operações com operadores de classe. É preciso modificar o código de avaliação de um operador.
								----> implementado a avaliação de operação com operadores nativos, e operadores não nativos.

	Atividades do Dia:
		----> (feito) implementação da classe matriz, como uma das classes da LinguagemOrquidea, exemplo: "int","float",...
							---> implementado a classe matriz, com operadores? +,-,*,/, <,<=,>,>=.
							---> modificação na classe Operador, para executar como uma função.
							---> modificado a classe EvalExpression, para executar operadores como se fossem uma função.
									---> a codificado dois tipos de execução de operação matemática: 1- operadores nativos, 2- operadores não nativos.

				----> (Insight) com a implementação não nativa de execução de operadores: é possível operadores unários, binários, ternários, quaternários, etc...!

				----> (feito) é possível otimizar a utilização de operadores em uma expressão: no construtor, avaliar os operandos, e acrescentar numa lista. Na próxima avaliação,
					  desse objeto Eval, os operadores podem ser encontrados mais rapidadamente, inclusive com utilização de indices, para sequencia de operadores na avaliação...
					

	   -----> o que falta para as atividades do dia:
					-----> (feito) testes com a classe matriz, é necessário implementar métodos, como ToString(), obter indices de celula de matriz,....
										---> implementado o método ToString(), para a classe MyMATRIX. (feito, aguardando testes)
										---> teste codificado.
										---> testes para operadores de matriz: +,-,*, passaram, operador: / falha, mostrando valores não-número.
					-----> (feito) renomear os nomes das funções e operadores a serem avaliados, está meio confuso..



					-----> (a testar) modificação aprovada de cache de operadores, implementada na classe EvalExpression, é preciso testar novamente a classe Eval.
					-----> (a testar) fixar o operador: / de matrizes, está em resultado [Nao Numero] para os elementos da matriz.
								---> (feito) codificar operadores de matrizes com uso de pilhas de operandos, e pilha de resultado. codificado.
												---> (a testar) aguardando testes, junto com testes da classe EvalExpression.
*************************************************************************************************************************************************************************************************************************
Resumo do dia:
			
			-----> implementação da classe Matriz, como uma classe nativa da linguagem.
					----> implementação de operações: +,-,*,/,>,>=,<,<=,==, para a classe matriz, um com uso direto de operadores definidos, outro com uso de pilha de objetos, para avaliação na classe EvalExpression.
			
			-----> testes para operações: +,-,*, sucessamente, operação: /, falha, resulta em não-números. aguardando testes para operadores condicional, e fixar operador: /.

			----> (Insight) com a implementação não nativa de execução de operadores: é possível operadores unários, binários, ternários, quaternários, etc...!

			----> (novo Insight) acesso a classes da linguagem suporte, via API Reflexão! Qualquer classe em C sharp pode ser instanciada e manipulada via API reflexão. Classes como 
			      MyMATRIX, por exemplo, que dá acesso à operadores para matrizes, pode ser instanciada via API Reflexão, criando objetos MyMATRIX.
			      quando instancia um objeto (classe Objeto), verifica-se se está no repositório de classes do orquidea, se não estiver, tenta via API- reflexão instanciar a classe,
			      copiando propriedades e métodos para um objeto Classe e acrescentando ao repositório de classes do orquidea. Então, no código orquidea, pode-se acessar métodos via sintaxe
			      do programa currente orquidea.	

**************************************************************************************************************************************************************************************************************************

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

Daily Scrum 30.12:
		
		Atividades do dia:

		 ----> (feito) implementar o importador de classes via API Reflexão. O texto dos método importados, por exemplo, contém um método Reflexão que é acionado via linguagem orquidea para executar algo...
		     propriedades (campos) da classe, contém uma cópia também dentro do objeto Objeto.	


		 ----> (feito) codificado a classe ImportadorDeClasses, que obtém via Reflexão uma classe de um Assembly e registra a classe extraida para o Repositorio de Classes orquidea.
					---> codificado na classe Funcao, um método de avaliação da função via dados carregados pelo importador de classes. Assim, dentro das instruções orquidea, é possível invocar uma função importada, via sintaxe default do orquidea.
					---> codificado na classe Funcao, um construtor com definição de método via API Reflexão.


		---> uma questão polêmica é se deveria registrar os métodos (funções) encontradas pelo importador,  no escopo raiz, ou modificar o procurador de funções da classe TabelaDeValores, para procurar funções também nas classes registradas no repositório de classes.

		---> (a testar) melhoria do código: a lista de tokens resumidos na classe UmaSequenciaID é desnecessária, e pode causa erros, razão pelo que foi removida da classe UmaSequenciaID. 

		---> correção do operador / para a classe Matriz: os cálculos de matriz inversa estão incorretos, é uma antiga versão, que não retorna números válidos.

		---> planejamento da inclusão da classe matriz com o código: os métodos para matriz seriam como  getters/setters, sobre um objeto que vem a ser um objeto da classe matriz.
		     Por isso, é essencial verificar definições de atribuição de matriz com chamadas a métodos de um objeto.

		Impedimentos para realizar as atividades do dia:
			----> visão mais clara da extensão de modificações de obter funções, e com relação aos operadores da classe EvalExpression, como obter os métodos extendidos de operadores, bem como o tipo de retorno dos operadores. Como está, os tipos de operadores estão fixos, como int, float, ou variável vetor, deveria na obtenção de operadores, especificar o tipo de retorno dos cálculos do operador...
						--> evitando erros de  polimorfismo na classe Eval, foi modificado o código desta classe, para determinação do operador currente, com tipo da expressão. Os tipos de dados estão escondidos por métodos operadores, e pilha de objetos genéricos. Ainda assim, a avaliação de expressões tem dois tipos de dados: variável singular, e variável vetor.
						    Tentar modificar isso.

  	
		----> pelo fato de operações com matrizes necessita da POO, e já ainda adiando a inspeção dos build para processamento de objetos, a próxima atividade é verificar os recursos POO nos builds, como definição de propriedades de objetos, e chamada de métodos com objetos. 
			
******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Resumo do dia:
		----> codificado um importador de classes da linguagem suporte C sharp.
		----> acrescentado na classe métodos, construtor para processamento de métodos importados.
		----> enxugando a classe UmaSequenciaID, que não tem mais uma lista de tokens resumidos.
		----> planejamento da classe Matriz, com acesso com getters/setters para manipulação de objetos matriz. Evita-se o acrescimo de mais um tipo de variável (variável Matriz) em diversos métodos, como Expressao.expressao(),  ExtraiExpressoes(), EvalExpression().
*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.12:


Atividades do dia:

		---> (a verificar) verificar e fixar os builds de definição de objetos (no build de definição de variáveis), e chamadas de métodos (no build de chamada de função).


		---> (feito) codificar getters/setters para manipulação de matrizes. set/get para manipular elementos da matriz. Funções nativas para +,-,*,/, codificadas,
									---> aguardando testes para divisão de matrizes, que utiliza técnica própria para calcular também divisão de matrizes não quadráticas.
											---> testes, dando resultados numéricos na operação de divisão, mas a ficar comparações com matrizes.inversas quadráticas.

						-----> (feito) métodos get/set para manipulação de um elmento da matriz codificado.
						-----> (feito) método para cálculo de inversa matriz quadratica codificado.
						-----> (feito) método para cálculo de inversa matriz não quadrática codificado.
			
		----> (feito) testar a classe de importação de classes da linguagem suporte.testes sucessamente para importar métodos, mas para propriedades, parece que só está importando variáveis estaticas. fixado propriedades importadas tem acesso por getters/setters, e campos são propriedades também, mas sem acesso por getters/setters.

		---> (feito) planejar e implantar utilização de métodos e propriedades, dispostos no repositorio de classes, modificando os métodos da classe TabelaDeValores, para compor
		acesso métodos vindos da linguagem suporte.
	
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.01:

	Atividades para o dia:
		---> (feito )modificar o importador de classes para acrescentar proriedades e campos estáticos na classe a ser  importada para o  repositório.
					---> fixado um erro de importação do tipo dos campos e propriedades.
					---> fixado um erro de importação do tipo a que pertence o método.

		--->- (feito) codificar um método na classe RepositorioDeClassesOO, construtor para objetos da classe no repositório.
		----> (feito) testar uma chamada de método, para classes importadas. testes, fixados, sucessamente.


		
		----> (a fazer chamada de método)  verificar e codificar funcionalidades para acesso e manipulação de objetos.
					--> (feito) modificado o build de instrução de atribuição, para conter processamento de objetos, registrados na tabela de valores do escopo currente.
								---> codificado o build e a instrução de atribuição de propriedade.
								---> TESTE para a instrução, se não haver passagem por referencia entre as propriedades, pode ocorrer efeitos indejáveis.

					--> (a fazer) modificar o build de chamada de método, para compor com objetos também. Chamadas com o sinal [.] é de uma propriedade ou objeto.

		---> (feito) codificar método  TabelaDeValores.ObtemPropriedadeAninhada(). 


____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrrm 02.01:

		Atividades para o dia:

		---> testar o método TabelaDeValores.ObtemPropriedadeAninhada().
			----> testes falha no processamento de instrução: "int A;". fixado, havia um método resumindo o que estava já resumido.
			----> testes falha no processamento de uma classe,  no método extratorDeClasses.ExtaiUmaClasse();
			----> o código de tokens do corpo da classe estava confuso e com erros de lógica. codificado.
		    ----> testes, um fato inusitado: variáveis inicializadas não estão compondo uma instrução de atribuição de variável! A fixar...
			----> fixado, o método pode ser utilizado para validar propriedades aninhadas. Nome do método mudada para: TabelaDeValores.ValidaPropriedadesAninhadas().

		---> testar o método tratador da instrução Atribuição de Propriedades.
				---> fixando o tratador da instrução de atribuição.
				---> verificando o processamento OO, o método ProcessadorID.ResumeExpressoes() não está resumindo propriedades e métodos com operador Dot.
				---> fixado, mas o processamento de uma propriedade de uma classe não está sendo feita muito bem, no método tratador de instrução de Atribuição de Propriedades.
							---> investigando, o operador "=" da expressão de atribuição não está inicializando o objeto Operador da expressao.
				
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrrm 03.01:
		Atividades do dia:

				----> fixar o erro de expressão de atribuição, na instrucao de definicao e atribuição de variáveis.
								---> codicar um operador Dot, para acesso a propriedades e métodos de um objeto. Este operador não está sendo reconhecido como um Operador, embora esteja nas definições da linguagem orquidea.
								---> codificado operador Dot para "int","float","string", a codificar para o tipo "Objeto".

					---> (feito) implementacao de manipulacao de objetos em metodo build e instrucao de definicao de variaveis.
								---> codificado a manipulacao de objetos no metodo buildDeVariavel.
								---> codificado a manipulacao de objetos no metodo instrucaoDeVariavel.

					---> a codificar o operador dot, para o tipo "Objeto". Codificar também um operador Dot neutro, para todas classes, um mesmo operador dot.


		Resumo do dia:
					----> planejamento de manipulaçao de objetos para definicao de variaveis feito.
					----> codificacao de métodos build e instrucao, para tratamento de modificacao de proprieadades de objetos.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.01:

Atividades do dia:
				---> é a parte final da POO: instanciação de objetos, que será tratada quando verificar definições de métodos...

				---> (feito) construir o cenario de teste para manipulacao de propriedades.
				---> (feito) testar e fixar o método build de definicao e atribuicao de variedades/propriedades,
					---->* uma visao: na verdade, não há propriedades aninhadas em uma classe, ou métodos! Porque no meio das propriedades aninhadas, há getters/setters que barram o aninhamento das propriedades.
				
				----> (feito) construcao de um cenario de testes para manipulacao de objetos em definicao e atribuicao de objeto.
						---> testes, falha na instanciacao do objeto do teste. Investigando, o método ResumeExpressoes(), fixadom aguardando testes. não está resumindo muito bem.
										----> fixado, o método ResumeManipulacaoAObjetos() está funcionando adequadamente.
						---> testes para o metodo build de definicao e atribuicao de variaveis/propriedades.
								----> falha no reconhecimento da propriedade a ser modificada.
									* na verdade, não há propriedades aninhadas em uma classe, ou métodos!
						---> testes feitos, fixado, o cenario de teste passou...

    			----> pode haver necessidade de mudar o construtor, e o método ExtraiExpressoes.

				----> (feito) construir o cenario de teste para definicao de metodos.
						----> testes, sem erros fatais, mas o registro da função não foi feito.
						----> (feito) fixado o método ResumeExpressoes(), que não estava resumindo os acessors, que não entram nos tokens de definição de sequencias id mapeada. Testes, o Match sequencias id está reconhecendo a sequencia id mapeada.
						----> (feito) testes para definição de metodos bem sucedidos.
						----> (feito) teste para definição de métodos, dentro de uma classe, bem sucedidos.
									----> um alerta: colocar um acessor antes da classe não há reconhecimento da classe. fixado, 
										  esta funcionalidade não foi prevista senão agora. fixado, testes sucessamente.

						---> teste para definição de métodos passou...


	---> ( opcional ) o código da classe matriz quebrou, mais um bug etéreo impossibilita obter operadores da classe.
		---> operacao de divisão para matrizes não quadráticas, segue a teoria consolidada, setando os numeros multiplicativos pelo maior numero elemento das matrizes operandas,
			retorna números não infinitos, mas números reais, porém com números muito pequenos. O alivio é que se formos calcular as matrizes inversas, pelos métodos padrões para matrizes
			quadráticas, retorna números infinitos como elementos da matriz resultante.

		Uma contemplação é que se há números infinitos na matriz resultante na operação de divisão em matrizes, a escolha de uma só solução é válido, dentre a faixa de números elementos da matriz resultante...


		O que falta para o dia:
			----> planejamento e codificação de atribuição de propriedades e métodos aninhados.

							----> o método MatchSequencias() reconhece propriedades aninhadas 
								  e resume bem, mas se tiver um getter/setter no meio, não vai reconhecer.


			    			----> codificar o metodo ResumeExpressoes() para capiturar propriedades aninhadas, com getters/setters (métodos) no meio da expressão.
										  ----> modificar o metodo build de atribuição de propriedades, para conter propriedades e métodos aninhados...



****************************************************************************************************************************************************************************************************************
----->Resumo do dia:
		1- ---> codificação do cenário de teste para definição de variáveis/propriedades.
		-----> testes, fixados, métodos build e de instrução de atribuição, passaram...
		---->* uma visao: na verdade, não há propriedades aninhadas em uma classe, ou métodos! Porque no meio das propriedades aninhadas, há getters/setters que barram o aninhamento das propriedades.
					---> ** a visão está errada!: pode haver propriedades e getters/setters aninhados, o que faz com que o método de definição de propriedades seja recodificada.

		----> revisão do código da classe matriz, provou que o código foi deliberadamente modificado para falhar, mas fixado...

		2- --->  codificação do cenário de teste para definição de métodos. testes sucessamente, demorou um pouco mais
				por causa do não planejamento da inclusão  de acessors para classes....

		---> operacao de divisão para matrizes não quadráticas, segue a teoria consolidada, setando os numeros multiplicativos pelo maior numero elemento das matrizes operandas,
			 retorna números não infinitos, mas números reais, porém com números muito pequenos. O alivio é que se formos calcular as matrizes inversas, pelos métodos padrões para matrizes
			 quadráticas, retorna números infinitos como elementos da matriz resultante.


		---> pode haver necessidade de mudar o construtor da classe Expressao, e o método ExtraiExpressoes.

****************************************************************************************************************************************************************************************************************
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.01
		
		Atividades do dia:

			---->(feito) testar o analisador de propriedades aninhadas.

			---->(feito) modificar o metodo ResumeExpressoes() para capturar propriedades aninhadas, com getters/setters (métodos) no meio da expressão.
										  ----> modificar o metodo build de atribuição de propriedades, para conter propriedades e métodos aninhados...
												----> codificando e testando a funcionalidade de propriedades aninhadas.
												----> quase lá, há uma confusão leve entre nome e nomeLongo da propriedade. O nome longo da propriedade 
												      serve para diferenciar propriedades de mesmo nome, porém vindo de classes herdadas diferentes.
											---> cenario de teste passou para uma sequencia de duas propridades aninhadas;


			--->(feito) nome e nomeLongo das propriedades modificadas: nomeLongo=nomeClasse+"."+nome;

			--->(feito) teste para processamento de instruçao de propridades aninhas feito sucessamente.

			---->(feito) trazer para metodos o conceito de propriedades aninhadas.
						  (feito) Foi feito um algoritmo para tratar propriedades e funcoes aninhadas (algoritmo guardado em ChamadaMetodos())
						  (feito) padronizacao para armazenar as estruturas aninhadas na lista de expressoes.
						  
			---->(a fazer) montar um cenário de teste para metodos aninhados.


	Impedimentos para fazer as atividades do dia:
			----> (feito) montar o conceito aninhamento para metodos.
							    ---> falta planejamento para o que fazer apos determinar o aninhamento: colocar dentro das expressões o aninhamento?
							    ---> uma chamada de método contém uma lista de expressoes-parametros, que são guardadas na expressão da chamada, cada expressao de 
									 chamada é armazenada na expressao principal na lista de expressoes.

			O VALOR DE SE MONTAR A VALIDACAO APOS A VERIFICAÇÃO DO TESTE, SERVE PARA TESTAR EM OUTROS MOMENTOS,
			A FIM DE VERIFICAR SE O CODIGO NÃO QUEBROU ANTE MODIFICAÇÕES EM OUTRAS PARTES DO CÓDIGO.

	Resumo do dia:
			---> planejamento para compor itens (propriedades e metodos) aninhados.
			---> codificacao do método ChamadaMetodo(), para conter itens aninhados.
			---> nome longo de propriedades e metodos modificado (o nome longo permite diferencias propriedades e metodos com mesmo nome, mas vindo de classes herdadas. Contorna o problema: "losango da morte" de linguagens de programacao orientada a objetos que tem somente uma classe herdada.).
			---> metodo ResumeExpressoes() modificado para compor propriedades aninhadas.

_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
DaiyScrum 06.01:


	    ----> testes para as atividades do Daily Scrum anterior: teste para propriedades aninhadas, falha na construção da instrução orquidea.
								---> fixado, codigo e nao tokens estavam sendo utilizados.
								---> fixado, o cenario para definicao e atribuicao de propriedades aninhadas passou no teste. 
					    					porém, o programa VM não executou corretamente.
											investigando,, a classe EvalExpression não está funcionando adequadamente. no cenario do teste, a expressçao a ser avaliada é "=1";
								---> a codificação dentro do método ChamadaDeMetodo(), torna obsoleto o código dentro do método DefinicaoDeVariaveis(),
									 mas a investigação da quebra de codigo da classe EvalExpression tem que continuar...
	
	Atividades do dia:
		
		----> (feito) verificar se o método ResumeExpressoes(), compoe metodos aninhados. Verificado, o método precisa de modificações.
						----> testes sucessamente, o método ResumeExpressoes() está resumindo tokens com chamadas de métodos.	
				
		----> (feito) investigar a quebra de codigo na classe EvalExpression, para o cenário de teste de propriedades aninhadas.
						----> programa VM com a instrução de atribuição, com propriedades aninhadas, funcionando adequadamente.

		
		----> (feito) utilizando a estrutura de dados com expressoes, planejada no Daily anterior,  compor o método de instrucao ChamadaAMetodo().

						----> (feito) estrutura de dados para propriedades e chamadas de metodos:
									---> guarda-se o nome do objeto, e para cada propriedade ou chamada a metodo aninhados, montar uma expressao, contendo dados do item aninhado.


						----> (feito) estrutura de dados para chamadas de métodos:
										----> uma chamada de método contém uma lista de expressoes-parametros, que são guardadas na expressão da chamada, cada expressao de 
											  chamada é armazenada na expressao principal na lista de expressoes.

						----> (feito )extrair o metodo de composicao de itens aninhados, guardado no método ChamadaMetodo(),
							 a ser utilizado também nos métodos ChamadaFuncao() (a fazer) , e DefinicaoDePropriedadesAninhadas() (a fazer).

		----> utilizando o método ChamadaMetodo(), retrabalhar no método ChamadaFuncao().

	    ----> montar o cenário de testes para propriedades e metodos aninhados.


		----> a parte mais dificil será: o que fazer quando o programador entra com um codigo errado?

********************************************************************************************************************************************************************************
Resumo do dia:
		----> testes sucessamente com o algoritmo para propriedades aninhadas. Algoritmo utilizado tornou-se obsoleto, com o método mais geral contido no método ChamadaMetodo().
		----> extração do método para propriedades E métodos aninhados.
		----> planejamento (para propriedades e métodos aninhados) e construção (para instrução de atribuição de propriedades).
********************************************************************************************************************************************************************************
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.01:

		Atividades do dia:
						----> (feito) utilizar o metodo de composicao de itens aninhados, utilizar também nos métodos
						                    (feito) ChamadaFuncao() (chamada a função não contem metodos e propriedades aninhadas, não sendo necessario a modificação do codigo), e (feito)DefinicaoDePropriedadesAninhadas()).
						----> (feito) montar o cenário de testes para propriedades e metodos aninhados.
										----> (feito) montado o teste para propriedades aninhadas, com o novo metodo de processamento de aninhamento.
													----> testes, falha, o codigo nao registra a propriedade do objeto alvo. Está utilizando os tokens da sequencia de entrada.
													----> fixado, erro de indices, testes passaram.
						----> (feito) construir mais cenários de testes.
								----> fixado, testes sucessamente para o cenario de teste com uma chamada de função,é preciso mais testes, pois não foi incluido propriedades, nem aninhamento de propriedades ou funções aninhadas...
								----> fixado, testes sucessamente para o cenario com propriedades aninhadas.
											---->(feito) refatoração do código de ProcessamentoDePropriedadesEFuncoesAninhadas(). Refatorado, testes passaram.

						----> a parte mais dificil será: o que fazer quando o programador entra com um codigo errado?
										----> Planejamento: a cada lista nula ou vazia, há um erro feito pelo programador...

	

		---> (feito) testar o método handler para definiçao e atribuicao de propriedade, que foi modificada com a adição do método Processamento de Propriedades e Metodos aninhados. teste para o método Processamento passou, mas a inclusão no handler precisa ser testado.
					---> falha, no processamento da instrução, falta padronização da estrutura de dados com expressoes, para propriedades e metodos aninhados na definicaoEAtribuicaoDePropriedades().
								----> fixado, havia um metodo que padroniza e empacota a propridade a ser guardada, o teste passou na avaliação da instrução.

		---> (a fazer) verificar se a propriedade aninhada alvo é a propriedade calculado pelo código, para receber um novo valor.
					   (feito, aguardando testes)planejar um modo de incluir a propriedade alvo nos cálculos de otimização de expressões.

					   tem que haver uma maneira de retornar um Objeto a partir das propriedades do Objeto raiz...
								--->(o que falta) criado uma copia de objetos-propriedade, para compor objetos que sejam modificados num aninhamento.
											----> (o que falta) falta implementar otimização de expressoes, quando modificar uma variavel-objeto da expressao.
											----> (o que falta) falta implementar o aninhamento de propriedades na classe Objeto.

*********************************************************************************************************************************************************************
Resumo do Dia:
	-----> verificado que o método ChamadaFuncao não necessita do método ProcessamentoDePropriedadesEMetodosAninhados, pois não trata objetos.
	-----> construção de vários cenarios de testes, para testes com o método ProcessamentoPropriedadesEMetodosAninhados(), testes passaram.
	-----> modificação no método build de atribuição de propriedades, para compor com o método Precessamento De itens aninhados.
	-----> planejado e implementado a otimização de expressoes modificadas, na classe objeto. (aguardando testes).


(insight) para tratar erros do programador ao utilizar a linguagem orquidea. todos objetos nullos ou listas nulas ou vazias, indicam que o codigo nao esta programado corretamente.
	
(insight desenvolvedor): quando uma classe é repetidamente e sucessamente testada, fazer
		um checklist anotando numa lista que a classe pode ser utilizada como "bloco" 
		para construção de outros métodos e propriedades.

**********************************************************************************************************************************************************************

______________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.01:

	Atividades do Dia:
				
				----> (feito) criar metodos para empacotar dados aninhados(propriedade, chamada de função).
				----> (feito) criar metodos para desempacotar dados aninhados.
							---> foi feito extensas modificações no tratamento de objetos, propriedades e métodos, alterando os 
								 métodos: DefinicaoDeVariavel(), ChamadaDeMetodo(). as modificações afetaram apenas as sequencias de POO.
							
							---> (feito) extensas modificaçoes no método da instrução de Atribuiçao, mas apenas nas sequencias de POO.

							---> (feito) no presente estado, há processamento de aninhamentos como: "x.y", ou "x.y()", ou "x.y(z,w)"...
							---->(feito) extendido para multiplas aninhamentos: como "x.y.z.w", ou "x.y.z()", ou "x.y.z.w(a,b)"...
										----> cada aninhamento anterior afeta o aninhamento seguinte, através de calcular o valor, atribuir à propriedade currente, e setar o objeto do aninhamento para o objeto que contém a propriedade currente.
______________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.01:

		Atividades do dia:

				---> (feito) cria uma nova instrução: Create, que instancia um novo objeto.
								----> instrucao: Create() (build).

				---> (a fazer) continuidade das modificações para POO, criar cenário de teste para:
								----> teste para metodo de ProcessamentoDeAninhamento.
								----> teste para DefinicaoDeVariavel, com uma sequencia POO.
								----> teste para ChamadaDeMetodo, com uma sequencia POO.

				----> (feito) planejamento para construtor do objeto. o construtor é um tipo funcao, onde se especifica o valor do parâmetro, e o nome do parâmetro, que é igual ao nome de uma propridade do objeto!
					  os construtores fican dentro da classe do objeto, precisam ser instanciados antes da utilização.			
					
					
				----> (feito) implantação de uma instrução para criar um construtor.
              				   ----> instrucao: Constructor(classe, propriedades[]). (build)


	----> talvez não seja preciso criar instrucoes orquidea para create() e constructor().
								----> a instrucao constructor() é instanciada uma vez por construtor de uma classe, não precisa realmente uma instrução que é compilada, e avaliado um numero infinito de vezes.
								----> a instrucao create() que cria um objeto, talvez precise de uma instrucao, mas está "amarrado" ao método build() de compilação.
												---> a instrucao create() tem que ter uma instrucao, pois deve ser utilizada em tempo real.


	  Impedimentos para atividades do dia:
				---> 1- (resolvido) como associar os parâmetros do construtor, com as propriedades do objeto. ---> nova instrucao: Create, cria um novo objeto.
				---> 2- (resolvido) como criar um construtor do objeto? ---> nova instrucao: Constructor.
				
				
________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 10.01:

		----> (feito) duas instruções novas criadas: Constructor (definição de um construtor para uma classe), e Create (criação de objetos).
					---> a instrução Create foi codificada o build e a instrucao.
					---> a instrução Constructor foi codificada o build.

		----> (feito) acertar o empacotamento do build da instrucao: Create, para incluir o nome do objeto que recebe a atribuição.

----> Impedimentos para fazer as atividades do dia:
		----> (resolvido) como criar construtores que modificam as propriedades do objeto criado?
			  (foi feito um contrato que as instruções orquidea do construtor modifiquem as propriedades do objeto, com acesso a um escopo particular, para o construtor).	

O que falta:
----> os testes de aninhamento.
		----> (a fazer) teste para metodo de ProcessamentoDeAninhamento passou no primeiro cenário, mas falhou no segundo cenário.
					----> falha no código em obter blocos de instrucao de metodos de classe. investigando, há falha no método ResumeExpressoes(). fixado.
					----> continuar o teste do segundo cenario.

		----> (a fazer) teste para DefinicaoDeVariavel, com uma sequencia POO.
		----> (a fazer) teste para ChamadaDeMetodo, com uma sequencia POO.


----> (feito) implementacao da instrucao orquidea  "Create" (criacao de objeto), com a estrutura de dados especificadas no build da instrução Create.
		----> (feito) foi preciso criar um metodo na classe funcao para tratar a instanciacao do objeto.
		----> codificar o cenario de teste para a funcao "Create". 

**********************************************************************************************************************************************************************************************************************************
Resumo do dia:
		---> criado instrução orquidea para "Create" Objetos.
		---> planejamento para o conceito da instrução: "Constructor".
		---> codificado o build para a instrução: "Constructor", não há necessidade de codificar uma instrução orquidea para Constructor,pois o código é uma meta-linguagem.
		---> iniciado a depuração para o cenário 2 do processamento de aninhamento. O método ResumeExpressoes() não estava funcionando muito bem, fixado, processamento de criação de classes, com funções com blocos, passou...

A fazer:
		---> testes para metodos de aninhamentos, cenário 2 de ProcessamentoDeAninhamento, DefinicaoDeVariavel(), ChamadaDeMetodo(). no método ChamadaDeMetodo(), talvez não precise codificar.
		---> teste para instruções "Create" e "Constructor".
***********************************************************************************************************************************************************************************************************************************
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum11.01:

Atividades do dia:

		---> testes para metodos de aninhamentos, cenário 2 de ProcessamentoDeAninhamento, DefinicaoDeVariavel(), ChamadaDeMetodo().
					---> (feito) fixado metodo ResumeObjeto(), e metodo handler ChamadaDeMetodo().
					---> (feito) fixado o metodo chave para o metodo ResumeAninhamentos() (retorna apenas o último aninhamento, que é o que importa para determinar o handler build, é uma aproximação para chegar a um método handler compativel. Ambos tipos de aninhamento (propriedade e chamadaDeMetodo) possuem um mesmo método de processamento de aninhamento.
						    Testes:
							---> (feito) teste para cenario 1 e 2 passaram.
							---> (feito) teste para DefinicaoDeVariavel(), passou, junto com o Cenario 2 Teste para Aninhamento.
							---> (feito) teste para ChamadaDeMetodo() passou, junto com o Cenario 1 Teste para Anihamento.
										----> verificacao de expressoes da estrutura de dados para chamadaDeMetodo(), fixado, mas é preciso fazer muitas expressao.Elemento[0]. cortado uma expressão.
											(fixado)----> verificacao de expressoes da estrutura de dados para DefinicaoEAtribuicaoDePropriedades(), a primeira expressão: instrucao.Elementos[0] está vazia.
											(fixado) ----> falha, mas na inicializacao dos dados do cenario: no objeto criado, todas propriedades são também objetos,que teriam que serem inicializados também. Teste cenario 1 e cenario 2 passou.	

		---> teste para instruções "Create" e "Constructor".
************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************
Resumo do dia:
		----> testes para cenario 1 aninhamento passou. (aninhamento de chamadaDeMetodo).
		----> testes para cenario 2 aninhamento passou. (aninhamento de propriedade).
		----> testes para handler DefinicaoDeVariavel no caso de aninhamentos passou.
		----> testes para handler ChamadaDeMetodos no caso de aninhamentos passou.
		----> fixado o método ResumeExpressoes() e método ResumeAninhamentos(),para retornar uma lista de tokens compatível com tipos de aninhamento.

		O que faltou:
			----> criação de testes para instruções "Create" e "Constructor".
***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 12.01:

-----> onde estamos:
		-----> POO funcionalidades.
				---> intruções POO: create, constructor.
				---> extrator de classes do código texto.
				---> chamada de construtores pelo build ChamadaMetodos().

				Com as instruções create, constructor, praticamente encerra atividades para POO.



Atividades do dia:
		---->(feito) padronizar os dados da instrucao Create, no build
		     (feito) Recodificando a instrucao Create, estava com muitos erros a fixar.
		----> testes para o build Create, e instrucao Create ( codificado teste).
					---> (fixado) testes para o build Create, falha. O termo-chave "create" não estava registrado na linguagem. é um termo extra, e foi incluido na lista dos termos-chave extras.


		----> (feito) refatorado a classe ProcessadorID, havia dados nas entradas dos metodos que eram redundantes.
				----> conversão os escopos na entrada de processadorid para processadorid.escopo.
		----> (fixado) refatoração quebrou o código! Favor ver o processamento de uma criação de uma classe.

______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 13.01:
		----> (agregação de valor para o projeto: classes C++ gerenciadas, com  reflexão C++!)
			   utilização de recursos em massa da linguagem C++, através de Wrappers Managed CLI C++, e uso de API de reflexão (que permite uso de 
			   interfaces padronizadas para acessar as classes CLI C++  Managed Code.
					----> Extensão aprovada, pelo acesso a mihares de recurso em C++, para o projeto Orquidea.
					        Porém, será implantada após o término de funcionalidades POO do projeto.

Atividades do dia:
		
		----> (codificado) testes para o build Create, e instrucao Create. (fixado, teste passou para criação de classes orquidea). 	
				  ----> testes para a avaliação de instrucao orquidea create, fixado a obtencao de expressões, com o método Expressao.ExtraiExpressoes(), houve saída válida, para a expressão da instrução create.
				  ----> (feito) uma pequena pausa, pois a instrução orquidea create exige um construtor válido para a classe. É melhor construir via codigo um construtor para a classe de teste.	
				  ----> testes falham, a expressao de parametros não foi passada, é preciso investigar.
				  ----> havia duplicação de informação na expressao empacotamento, e não passagem por referencia a lista de parâmetros.
						-----> fixado as irregularidades na instrucao orquidea create.

				  ----> (fixado o build de create), formação da instrução orquidea create, processeguindo para a avaliação da instrução create.
						-----> falha para encontrar um construtor compativel. Investigando, as expressões dos parâmetros não possuem tipo.
						-----> volta para planejamento: as expressões calculadas da analise do codigo não tem tipo. talvez seja preciso pesquisar se os elementos da expressao são variaveis simples, variaveis vetor, ou objetos.
						-----> fixado, o tipo da expressão é determinada na construcao da expressao, ou no metodo Expressao.ExtraiExpressoes().

						-----> (fixado) uma verificação mais, não é a expressão que tem que ter um tipo, cada elemento da expressão é que tem que ter um tipo.
								---->(fixado) Não encontrado o construtor compativel, mesmo com os tipos de expressao determinado.
									----> encontrado o construtor compativel!. 
				  ----> continuando o teste para instrucao orquidea create.


		----> modificaçoes no código para se tornar mais cheios de recursos, foi determinado que parametros de construtores fosse expressoes, nao propriedades ou objetos ou variaveis.
				----> (feito) completar a extração de expressoes no build Create().

		----> (a codificar) testes para o build constructor, que precisa de uma instrução orquidea que será avaliada apenas uma vez, no inicio do programa VM.
		----> (a testar) completar os testes para a instrucao create.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 14.01:


Atividades do dia:
			----> (feito) completar os testes para a instrucao Create. O teste para instrucao "create" passou...
						----> (fixado) testes, o build e a instrucao funcionam, mas o nome do objeto criado pode ter saido incorretamente.

			----> (fixado) modificar o construtor de expressoes, para compor o tipo para expressoes monoUnidades.

			----> (feito) codificar o método para o build constructor.
						 ----> o codigo quebrou! ante as modificações da classe Expressao, e ProcessadorID.
							 (fixando) o construtor de Expressao() e metodo Expressao.ExtraiExpressoes() está com uma série de erros, com as modificações deste dia.
							 (falha) regressão para um teste de ExtraiExpressoes(), falha na obtenção dos nomes dos operadores.
									----> a fixar o nome dos operadores no construtor de Expressao, verificado que o errro está no construtor de Expressao.
									----> (fixado) em expressões complexas, há processamento, só está faltando o nome dos operadores nas expressoes construidas.
									----> expressões construidas tem o tipo de expressao definido...
					     ----> teste para build constructor passou... foi gerado uma instrucao orquidea para a instrução: construtor.

			----> (feito) planejamento para instrução orquidea construtor, com a estrutura de dados passa pelo build.
					-----> isto não tem a menor importância: o arquivo compilado contem as expressões que as instruções precisam,
					a planejar como isso será feito (um arquivo XML?).
					-----> construido o metodo para a instrução construtor, testes concluidos.
					-----> teste para a instrucao constructor passou...
					
________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.01:


Atividades do dia:
				----> procurar por gargalos no codigo, que estão atrasando o desempenho do processamento.
							---->(feito) um dos gargalos era a extração de expressoes que não era utilizada no codigo. metodo CompileEscopos().
				----> iniciar testes de aceite: um programaVM completo, com muitas instrucoes. o texto do teste pode ficar em um arquivo local.
_________________________________________________________________________________________________________________________________________________________________________________________________________________________				
Daily Scrum 18.01:

		Atividades do dia:
				-----> (feito) melhor planejamento para a instrução "return", e retorno dos métodos Eval(), que dependiam do uso da pilha de objetos. 
							-----> (feito) modificação no delegate que define uma instrucao orquidea: agora tem um tipo de retorno, "object", e a instrução  "return"",
							funciona como as instruções "break", "continue", aninhado dentro de outras instruções.
											---> perde-se uma funcionalidade que nem todas instruções são obrigadas a cumprir, porém explicita melhor design, e simplicidade em instruções de "return" e "chamada de método/função".
											A classe EvalExpression melhora também o retorno do cálculo de uma expressão.

				----> (feito) visando o desempenho de processamento de sequencias id, foi modificado o método Processador.Compile(), para em vez de remover tokens,
							 atualizar o iterador de tokens.

				----> (a testar) ante a modificação no código para retorno de instruções, retestar instruções que exigem blocos de instruções, como "for", "while", "if".
							---> (fixado) testes, falha no build da instrucao "for", não está registrando a variável de definição parâmetro.
							---> (fixado) testes, falha no build da instrucao de definicao de variaveis, não está reconhecendo a expressão de atribuição. O erro descrito para a instrução "for" pode ser deste erro de definicao de variaveis.
									---> (a fixar) o teste para as instrucoes "for", "while", "if", está desatualizado, o escopo do ProcessadorID não registra as modificações de escopo.
									---> atualizado o teste, mas continua a não registrar as variaveis. O escopo continua a não ser atualizado, apesar do handler build da definicao de variavel registra corretamente a variavel no escopo.

				----> uma variavel vetor nao é registrada pelo build definicao de variavel.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 19.01:

				----> (passou) testes para instrucoes  "for", "while", "if", com um teste atualizado.testes, falha, o processamento reconhece as variaveis e as registra, porêm há repetição para uma só variável, a instrução for também não esta sendo reconhecida.
						---> o problema foi a modificação de não extração de expressões, no método ProcessadorID.CompileEscopos(), supondo que o desempenho do processamento, seria mais rápido, e que os tratadores não estavam utilizando as expressoes extraidas no método ProcessadorID.CompileEscopos().	
								---> testes, falha, o escopo folha não é passado as variaveis para o escopo pai. (fixado), o escopo folha não guardava a referencia antes da compilação do bloco...
								---> teste para "for" passou.
								----> teste para "if" passou.
								----> teste para "while" passou.
								----> teste para chamadas de função, definição de função, instanciação de variavel com erro passaram.

				----> (passou) testes de aceites, com leitura do código em arquivo texto. (cenario aceite 1 - definicao de funcao estruturada ):
								----> testes para o cenario 1 não passou, o codigo nem compilou. O erro está no build de definicao de funcao.
											----> falha do desenvolvedor, a definição de função não cria instrução de definição. Vendo isso, e verificando no escopo
											se a função estava definida e corretamente, com instruções aninhadas, escopos folhas, definicao de variaveis, estava tudo correto...
											----> token "return" não estava previsto nos termos-chave extras da linguagem, fixado, instrução "return" dentro da definição de função passou...

				----> implementado uma validação de elementos de expressoes, em ProcessadorID.ExtraiExpressoesDeUmaInstrucao(), uma verificação a mais, captura erros de não definição prévia de um elemento de expressão.
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.01:

 
		Atividades do dia:

					
					 (feito, testado) cenario aceite 2 - construção de classe POO. 		

				----> (codificado) cenario 2 de aceite: construção de uma classe completa, com propriedades e métodos totalmente especificados.
									---> falha, nem todas instruções de um bloco estão sendo registradas no bloco do corpo da função. (fixado), mas há duplicação de blocos, e os metodos da classe não estão sendo registrados.
													---->(fixado) o problema do dia é que: o escopo muda a cada construção de um método ProcessadorID. resolvido: o escopo construido de outro escopo, não estava adicionando todos tipos de itens do escopo a clonar.
							(feito)	---> cenario 2 de aceite passou...

				----> (feito) tarefa: corrigir o metodo de parser do ParserAFile, há problemas com a identação das linhas do codigo guardado em arquivo, gernado tokens como "\t".
									---> os caracteres como newline (\n), tab (\t) presentes num arquivo, foram removidos das linhas de codigo.
									---> com o advento de varias linhas de codigo, permite uma apuração exata para a classe PosicaoECodigo(), que posiciona uma instrução dentro das linhas e colunas do codigo texto utilizado.
									
				----> (a fazer) falha no componente ParserUniversal, há tokens termos-chave no MEIO de tokens. Fixar urgentemente o método da classe ParserUniversal.
									---> (aguardando testes) codificação para tokens polêmicos refeita, aguardando testes. Regressão para Corpo_Testes_01, cenário de testes para tokens polêmicos.





				Conforme o projeto foi progredindo, verificou-se que pode ser usado o nome longo para uma classe, sem quebrar os demais códigos:	
				----> Planejamento para  uso de nome longo para classes, para evitar o problema do losango mortal. O código deve saber quando usa nome curto, ou nome longo, ou apenas um nome longo, em todas situacoes.

				----> planejamento para a inclusao do termo-chave "void".
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.01:
		

		----> (feito) codificação para tokens polêmicos refeita, aguardando testes. Regressão para Corpo_Testes_01, cenário de testes para tokens polêmicos.
						
		----> teste de cenario 3, classes com herança.
						----> ocorreu no metodo CaracteresID, simplesmente deletaram letras (i,j,k, I,J,K) que formam caracteres validos... fixado.
						----> heranca e deseranca totalmente refatorado, para maior legibiidade e manutencao do codigo.

		-----> planejamentos:
					----> planejamento para  uso de nome longo para classes, para evitar o problema do losango mortal. O código deve saber quando usa nome curto, ou nome longo, ou apenas um nome longo, em todas situacoes.
					----> planejamento para a inclusao do termo-chave "void".
____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.01:
		
		Atividades do dia:

				----> (implementado)implementacao de nomes longos(nomeClasse+"."+ nomePropriedade, nomeClasse+"."+ nomePropriedade) para propriedades e metodos...
				----> (a implementar) implementação de validacao de nomes de propriedades ou metodos com mesmo nome, mas com nome de classes diferentes(o problema do losango mortal).
_____________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.01:
	
		Atividades do dia:
				---> otimização do método MatchSequencias().
							----> todas sequencias já mapeadas são resumidas previamente.
							----> se uma sequencia a mapear começa com um termo-chave, como "for", "classe","if" e não for um acessor, faz um processamento mais rápido.
______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.01:
		Atividades do dia:
				---> otimização do método MatchSequencias()
							----> sequencias id já mapeadas com inicio com um ID, está numa lista com estas sequencias id.
							----> se no método MatchSequencias(), a sequencia de entrada começar com um ID, inicia uma comparação com a lista de sequencias id já mapeadas com começo ID.
_______________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 24.05:
		Atividades do dia:
					----> inclusão no arquivo xml de definicao, os comandos "create", "constructor", "importer", "casesOfUse".
					----> (codificado) o build da instrução "importer", o metodo de execução da instrução "importer", e o codigo da instrução "importer".
					----> verificar se há metodo para tratamento/incluir o metodo para tratamento de metodos/propriedades "static".
								----> há metodo para tratamento de propriedades estaticas, mas nao para metodos estaticos.


					----> criar uma classe para integrar todos passos para construção de um novo comando: string id, metodo build, metodo handler, codigo id da instrução.
________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 25.05:
		Atividades do dia:
					----> (continuando a daily scrum anterior) criado uma classe para integrar todos passos para expandir a linguagem orquidea.
							---> (codificado) funcionalidade para carregar extensoes da linguagem a partir de arquivos externos (Assemblies).
					----> criar o build para metodos estaticos.
				

________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.05:
		Atividades do dia:
					---> save/load de expressoes em arquivo xml.
								---> (aguardando testes) codificado uma classe para gravar/ler listas de expressoes.
											---> testes, falha na compilação, na interpretação do token "class". Verificando a extração de tokens no parser universal está falhando.
															---> (fixado, a conferir em teste)(falha) na obtencao de tokens na classe ParserUniversal.
																		---> o metodo ParserUniversal.GetTokens() esta trabalhando no inicio, a conferir no seguimento do algoritmo.
																				---> (fixado)localizado o bug: está na obtencao de ids, sem a validação de tokens polemicos.
																						---> (fixado) mas nao esta registrando parenteses e bracas como termos-chave presentes. Havia um trecho de codigo antigo que nao trabalhava com o metodo PreencherVazios(), que nao altera os indices do texto, por isso nao ha que se falar em modificar o indice da malha...
																				---> (falha) nao está reconhecendo os parenteses na retirada de ids presentes.
																						---> falha ao determinar termo-chave que pode aparecer como string de cumprimento==1.
																						---> falha na inclusao de operadores presentes. nao está incluindo os operadores presentes na lista final de tokens.
																						---> a falha final estava no texto de retirada de tokens, tinha que ser o texto original.
																						---> possivel falha na inclusao de operadores como "++". Nao, no cenario de teste nao estava incluindo operadores ++, e houve ordenacao nos operadores, quanto ao seu cumprimento de letras, o que retira a possibilidade deste tipo de erro....



															---> (fixado) falha na obtencao das producoes, termos-chave, e operadores: retornando lista de producoes e operadores com elementos iguais.
																  houve falha na manutencao do arquivo XML de configuracao de producoes, operadores e termos-chave. Os ID estavam sem [], resultando em termos chave como ID.
																  

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.05:
		Atividades do dia:
					---->(fixado) fixado o bug que não reconhecia a sequencia mapeada para compilação: a cada nova instância de processadorID, recalculava a lista de tratadores, duplicando a lista, pois estava calculando novamente.
					
					---->(modificado) o codigo da classe propriedades, no metodo propriedades.ToString(), para incluir o tipo na visualização da propriedade.


					---->(codificado) metodo para escrita em arquivo XML de objetos da classe Instrucao.
					---->(codificado) metodos para escrita de propriedades e de metodos (funcoes).
					---->(codificado) metodo para leitura de propriedades.

					----> por principio da unica responsabilidade de classes, foi particionado a classe de leitura/gravacao, para classes de propriedades, metodos, expressoes, e instrucoes, em separado.

					----> testes para escrita em arquivo xml, de propriedades e metodos.
							--->(codificado) o cenario de teste para gravar/ler propriedades, em arquivo xml.
										---> falha na leitura de propriedades, o sistema teima em dizer que não é possível compilar um XElement através do Enumerator de documentos xml.
										---> em uma parte do codigo de outro projeto, que foi testado, nao houve problemas em converter um XmlText em XmlElement... talvez seja um problema de versao do Framwwork (no projeto em que funciona, é NetCore3.1, e o projeto atual é Framework4.7).
										---> verificando a definição do Enumerator, é um Enumerator para o tipo XmlNode. Mas não está retornando os elementos propriedades, apenas o elemento raiz.
										---> modificado o codigo para obter uma lista de XmlNodes, mas está retornando uma lista vazia.

					---> codificar a conversao de XML para uma classe inteira, pois a classe contem todos metodos e propriedades do codigo, definições estão dentro das classes.

____________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.05:
		Atividades do dia:
				----> codificado uma extração de expressoes sem validação no escopo, util para o processamento de leitura de instrucoes guardadas em arquivo XML.
				----> fixar o bug da leitura de propriedades guardadas em arquivo XML.
								---> modificado a gravacao de propriedades em arquivo XML, para gravar uma lista de propriedades.
								---> verificar se é o cabecalho do arquivo XML é que está causando o bug.
											---> (aguardando testes) retirado o cabecalho, deletado o arquivo XML para um reset.
											
				----> verificar se há vazamento por referencia na classe de Extracao de Classes.
				----> codificar a conversao de XML para uma classe inteira, pois a classe contem todos metodos e propriedades do codigo, definições estão dentro das classes.
				
				----> parece que o codigo para gravacao de expressoes em arquivo xml, pode ser resolvida se incluir um campo indicando o tipo de elemento da expressao, sem utilizar uma extracao de expressao sem validação.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.05: (segunda)
		Atividades do dia:
				----> (fixado) fixar o bug se tempo de carregamento para ProcessadorId.InitMapeamento.
							---> retirado o mapeamento para sequencias id começando com Ids, havia um inexplicavel processamento lento no metodo InitMapeamento(), e 
							     o metodo que utilizava o mapeamento era redundante...


				--->  (testado, fixado) TESTAR O ProcessamentoID, houve modificação no codigo.
							---> os tokens da classe estavam sendo extraidos sem os operadores braças.

				---> (testado) testes para gravacao e leitura em arquivo xml, de listas de propriedades.
									---> arranjo de parametros para construtor modifcado, havia confusão em como inicializar e como gravar o arquivo xml.
									---> é um bom problema de design de classes, ha dois parametros que são essenciais: o documento xml. e o nome deste documento xml. o documento xml é para gravar o documento, criando ou adicionando (append), e o nome do arquivo xml é para leitura do arquivo xml. Depois de refatorado, o parametro document foi retirado, e o nome do arquivo xml foi movido para os metodos read() e write().
									---> o teste para leitura/gravacao de propriedades passou.


				
				---> (VERIFICAR) se as instrucoes orquidea estao sendo registrados nos metodos da classe extraida.
									---> o metodo de extração de classes quebrou!!! (fixado, os tokens braças estavam incluidos no processamento do corpo da classe).
									---> instruções dos metodos não estão sendo processados...
									---> mais uma vez, a perda do pendrive eliminou os testes para construcao de instrucoes.
									---> (fixado) o codigo do ParserUniversal.GetTokens() quebrou!! Nao processamento do token ";"
												---> o token ";" esta como termo-chave da linguagem. mas a determinacao de tokens id não está funcionando... Há um token ";" junto com um possível id.
															----> fixado os tokens juntos com um termo-chave presente, mas o termo-chave presente ";" nao está aparecendo.
																		---> enfim, nao estava processando termos-chave que apareciam mais de uma vez, nos tokens nao ordenados.

				
				---> testes para gravacao de arquivo xml, expressoes.





				----> RECOMENDA-SE A CODIFICACAO DE UM NOVO TIPO DE TESTE, A PARTIR DE UMA CLASSE CONTAINER DE TESTE, QUE TESTA CADA METODO INSERIDO NUM OBJETO DA CLASSE DE TESTES..
					---> FALTA DE COBERTURA DE TESTES, E MELHOR REGIDIBILIDADE DO CONTAINER DE TESTES.

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 01.06: 
		Atividades do dia:
					---> verificar se o processamento de blocos, com a instrucao "while", está sendo corretamente feito.
									---> falha no metodo atribuicao, não está sendo verificado que uma atribuicao está sendo feita, para um parametro da funcao, do jeito que está, em uma atribuicao de uma variavel não está sendo processado porque a atribuicao num parametro da atribuicao da variavel nao está sendo levado em conta.
													---> tentativa de incluir o parametro como atribuicao, dentro do build de metodos, falha.
													---> é um erro de definicao de qual escopo utilizar: o escopo do processador id, ou o escopo passado para o metodo Compile (que é o correto).
																	---> o erro está agora na construcao do bloco... verificando, o erro está na nao atribuicao de variavel, sem o tipo definido na atribuicao: x=x+1, "x" não tem tipo, foi definido anteriormente em outra atribuicao.
																	---> fixado a atribuicao de variavel sem tipo na instrucao, mas agora as instrucoes nao estão sendo repassadas fora do build de variavel.
																	---> o mundo é mesmo engraçado... não modifiquei o código, e as instruções apareceram do nada... há algo muito podre no reino da Dinamarca..

									---> (fixado) nao há opcao para atribuicao de variavel para uma atribuicao sem tipo da variavel.

									---> (GRAVAR NA MEMORIA) falha na sequencia de instrucoes. a instrucao de atribuicao x=x+1 deveria estar dentro do bloco de instrucoes while..
																	----> a instrucao de atribuicao x=x+1 deveria estar no BLOCO WHILE, MAS ESTÁ NA INSTRUCAO DO PROCESSADOR PRINCIPAL!!!
																	----> a sequencia foi fixada, MAS A INSTRUCAO DE ATRIBUICAO DEVERIA ESTAR DENTRO DA INSTRUCAO WHILE, MAS ESTÁ NAS INSTRUCOES PRINCIPAIS.........


					---> (fixado, testado) teste para leitura/escrita de expressoes.
									---> metodo escrita de expressoes passou.
									---> metodo leitura de expressoes passou.
									---> refatoração nos metodos de manipulacao com arquivos xml.

								---> codificado um metodo de inicializar um arquivo xml, criando um arquivo novo, possibilitando operacoes de escrita em arquivos xml.

________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 02.06: 
		Atividades do dia:
				----> modificacao do codigo de funcionalidades xml, para compor com elementos XmlNode em vez de XmlElement, na leitura de expressoes, instrucoes, metodos.
				----> (teste para leitura/gravacao de expressoes), passou, com a nova composicao com XmlNodes.
				----> (teste para leitura/gravacao de propriedades) passou, com modificacoes para leitura de propriedades com um elemento raiz.
				----> (teste  para gravacao de instrucoes, em arquivos xml), falha na gravacao de expressoes, o metodo expressoesXml.Write(), fora da classe ExpressaoXML, não está funcionando.
									---> codificado um novo construtor da classe expressao para guardar o documento da classe de instrucao, eliminando a incompatibilidade de nos em diferentes contextos.
									---> (teste) fixado, testado, teste para instrucoes xml passou no metodo InstrucaoXML.Write(), SEM instrucoes de blocos.

				---> codificado construtores para importar um XmlDocument, possibilitando a composicao de propriedadesXML, expressoesXML, instrucoesXML, metodosXML, entre si.
				---> (teste para leitura de instrucoes, guardadas em arquivo xml), falha ao obter o XmlNode raiz do documento. 
									---> fixado, o no raiz do arquivo xml comeca com o nó [file], que nao foi incluida no metodo.
									---> nao esta registrando a lista de expressoes, a construcao de expressoesXML no metodo Read() está incorretamente setado.


									--->(codificado) Codificar para obter uma lista de instrucoes, e fixar o XmlNode raiz para expressoes lidas, no metodo Read().
												---> (testes, falha) testes com obtencao de expressoes a partir de um caminho, falha, o no xml da lista de expressoes=null.
												---> (codificado) codificar um metodo melhor para obter expressoes, a partir de um XmlNode de uma instrucao.
												---> teste para Instrucao.Read(escopo) passou. Mas é preciso testar para Instrucao.Read(escopo, XmlNode), e para uma instrucao que contenha um bloco de instrucoes.


									---> Fixar novamente a instrucao while, não está registrando a instrucao, sem modificar o codigo, o BUG surgiu do nada!!!!

												---> FALHA NOSSA: ao nao remover o token while, o registro da expressao estava resultando em erro...
												---> (fixado) e tem mais: a instrucao atribuicao do teste nao deveria estar aparecendo na lista de instrucoes, mas sim no escopo da classe "classeA"!!!
												---> (a fixar) e mais: as instrucoes do corpo da metodo nao está sendo listado!!!									
																---> o processador de id está retornando como o processador de ids da classe!!!.
																---> é um problema de inicialização de propriedades e escopo da classe ProcessadorId, o escopo está com a lista da classe inteira.

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.06: 
		Atividades do dia:
				---> É preciso testar para Instrucao.Read(escopo, XmlNode), e para uma instrucao que contenha um bloco de instrucoes.

				---> (a fixar)	---> o processador de id está retornando como o processador de ids da classe!!!.
											---> isolando o problema, está na extracao de classes. 
								---> é um problema de inicialização de propriedades e escopo da classe ProcessadorId, o escopo está com a lista da classe inteira.
											---> verificando, os tokens do escopo está incorreto, na inicialização de processador id.
													----> testes, falha, a extracao de metodos e propriedades da classe nao estão sendo registrados.
													----> nao tem nada de engraçado, de uma hora para outra as instrucoes obtidas no processador id começaram a aparecer.

											----> faltando retirar o bloco de corpo de funcoes.... e do bloco da instrucao while.
													----> o sistema teima em nao reconhecer modificacoes no metodo BuildBlocos().
       												---> o sistema teima em atrapalhar, nao bastasse o aparecimento da lista de instrucoes, o processamento de blocos é inócuo, nao retorna nenhuma instrucao.
													---> fixado o problema de obter instrucoes, com a propriedade horroroso de instrucoes_static, mas o sistema teimar em duplicar a atribuicao do bloco.
													---> testes, quase lá, faltando remover a duplicacao de instrucoes do processador.instrucoes, para a atribuicao x=x+1;


				----> VERIFICAR NA CLASSE INSTRUCAO SE HÁ PROBLEMAS DE REFERENCIA.
								---> RETIRAR O CONSTRUTOR DE INSTRUCAO QUE CONTEM COMO PARAMETROS UMA SequenciaID.
______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.06: 
		Atividades do dia:
					
					----> (verificado) VERIFICAR NA CLASSE INSTRUCAO SE HÁ PROBLEMAS DE REFERENCIA.
								---> verificando, há possiblidade de problemas de referencia, justamente no objeto de umaSequenciaId.

					---> (retirado) RETIRAR O CONSTRUTOR DE INSTRUCAO QUE CONTEM COMO PARAMETROS UMA SequenciaID.

					----> testes para classe com uma propriedade, e um metodo, falha na construcao de bloco para a funcao.
								---> falha na construcao de bloco para a instrucao while.

					---> o codigo de ParserUniversal.GetTokens() quebrou!!! Não está processando o token ";", está juntando numeros com o tokens ";".
								---> correcao de caracteres validos como false para numeros. Se for um numero, nao será um caracter valido, agora.

					---> modificado o metodo ProcessadorID.BuildBlocos, tornando mais robusto e menos sujeitos a nao processamento.
					---> testar a instrucao "if/else".
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.06: 
		Atividades do dia:
					---> testes para a instrucao if/else, falha, não está retornando as instrucoes corretas. No build de "if", problemas de extracao de expressoes, no comeco do metodo.
									----> verificando o metodo expressoes.ExtraiExpressoes(), não está parando na condicão de uma malha "while".
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.06: 
		Atividades do dia:
					---> continuando o teste para validação de blocos, fixado a extracao de expressoes, pelo metodo expressoes.ExtraiExpressoes().
					---> (fixado) falha ao tentar obter os tokens de um bloco, remocao de variavel estatic para obter instrucoes, estava para cobrir a falha de referencia para o escopo.TabelaDeValores.

					---> a ordem dos blocos está sendo antes da instrucao que chama o bloco: a instrucao if/else está vindo como [bloco].instrucoes + if/else.instrucao,
					quando deveria vir como if/else.instrucao + [bloco].instrucoes.
									----> a constatacao é obvia: o processadorID do bloco está registrando as instrucoes antes da instrucao que define o bloco...
									----> aparentemente o problema foi fixado: mas o bloco está sendo construido sem incluir como bloco a instrucao principal. Fixar modificando o metodo BuildBloco(), passando como parametro a instrucao principal.

									----> fixado o bug de ordem das instrucoes, mas nao está claro se o bloco da instrucao if está sendo processada corretamente...
													----> verificando, os blocos nao estao sendo associados à instrucao "if/else".
													----> nao esta sendo razoaveis, as instrucoes do processador está sendo incluido no processador id principal.
																	----> fixado, o bloco primeiro está sendo incluido na instrucao principal, mas como 2o. bloco, quando deveria ser o 1o. bloco.
																					---> fixado, a instrucao principal estava incluindo um bloco vazio, na construcao da instrucao principal.

				   ----> verificar se há erros de referencias em classes parciais.
										---> verificado, há problemas quando se utiliza classes parciais. Tentando solucionar utilizando como public a lista de instrucoes. falha, nao resolveu o problema de referencias para classes parciais. Talvez seja porque os builds estão como privativos...
																	---> tentando fixar o problema de referencias de classes parciais, declarando os builds como protecteds.
																				---> se nao resolver, eliminar a classes parciais, copiando a 2a. parte para a 1a. parte da classe parcial.
																				---> nao foi fixado, as instrucoes do processador estão sendo construidas sobre as instrucoes do processador id principal.
						


          		   ----> (fixado, utilizando polimorfismo para metodo BuildBloco) fixar o bug para o build de definicao de Funcao.

				   ---> tentando eiminar o bug de classes parciais para a classe ProcessadorID, foi separado as partes da classe parcial id, criando uma nova classe, para conter os builds de instrucao.
										---> nao foi eliminado o bug de processador de ids, justamente porque é passado uma referência para o processador do build.
										---> o codigo do processador id quebrou! nao está registrando os blocos de instrucoes, mas sim as instrucoes dadas na sequencia, sem ligar as instrucoes a seus blocos...
																		---> (fixado) tambem nao está registrando as instrucoes principais, como "if". (fixado) Continua registrando as instrucoes sem seus blocos.
																		---> (fixado) falha ao determinar a lista de instrucoes, mas as instrucoes com blocos está sendo feita corretamente.

										---> (fixado) a solução continua com problemas de referencia no processador de ids, contornada com inserções/remoções de instucoes bloco.

					---> refatoracao, para evitar o problema de ProcessadorID com referencias falhas.
										---> evitando acesso a lista de instrucoes implicitamente, foi refatorado o código.

					---> testes, a refatoração foi bem sucedida! Não só compilou as instruções, como também compilou os blocos de instruções dentro da instruções principais...
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.06: 
		Atividades do dia:
					---> devido a perda do pen-drive em maio/21, é necessário retestar todas instruções de linguagem orquidea, para programacao estruturada e programação orientada a objetos...
										---> codificado um cenario de testes para varias instrucoes: if, for, while, atribuicao de variavel.
														---> testes, falha, só está registrando a instrucao de atribuicao. Verificando, só a instrucao "for" não está funcionando adequadamente...
														---> fixado um antigo codigo, que levava em conta o primeiro termo-chave como determinante da sequencia id a ser identificada.
														---> testes falha, no build da instrucao "for".
														---> mais uma vez, fixado um antigo codigo, anterior a perda do pen-drive em maio, no build da instrucao "for".
														---> (fixado) a instrucao de atribuicao estava faltando justamente o caso de uso para o tipo de atribuicao da instrucao "for".
																		---> (fixado, a instrucao "for" estava com codigo antigo e nao validado, por causa da perda do pen-drive em maio/21) está registrando mais de um bloco, é preciso apenas o registro de um bloco.

				   ---> falta de cobertura de testes, é preciso tb dividir a instrucao de atribuicao, para facilidade de testes.
										---> divisão da instrucao BuildInstrucaoDeVariavel, para melhor cobertura de testes.	
										---> (codificado) (codificar teste para inicializacao/atribuicao de propriedades, variaveis, estaticas ou nao).
														---> aguardando rodar o teste para inicializacao/atribuicao de propriedades, variaveis, estaticas ou nao.
														---> (retirado) talvez seja necessário retirar metodos auxiliares para os builds de atribuicao/definicao de variaveis/propriedades, para melhor visualização e legibilidade do código.
										---> refatorado o codigo para melhor regibilidade, cada instrucao de definicao de proopriedade/variavel está com codigo duplicado, MAS os testes pegam qualquer bug, pois cobrem todo o codigo de definicao de propriedade/variavel.
					
					
					---> divisao de BuildDeDefinicaoFuncao em dois metodos mais simples, para Metodos e para Funcoes.


					--> (rodar o teste para os varios tipos de definicao de propriedades/variaveis).

					--> (codificar cenario de teste para build de definicao de metodo/funcao).

 			       ---> dando continuidade do escopo desta manutenção, é preciso codificar leitura/gravação em arquivo xml, de métodos. Com esta funcionalidade, é possível guardar classes inteiras em xml, com propriedades, metodos, e instruções em métodos....
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.06: 
		Atividades do dia:
					---> testes para diferentes formas de atribuicao de variaveis/propriedades.
							---> (fixado) falha, nao está registrando as variaveis na tabela do escopo.
							---> (falha) na obtencao de tokens! o metodo GetTokens() quebrou!!!. (fixado)
										 ---> veja bem: sem as validações de todas declarações de variavel/propriedade, eu nao posso continuar com o restante do projeto!!!

___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 05.07: 
					---> (testado) testar chamada de metodo de classe importada.
							---> testes, falha na extração de expressões: operador @ não está sendo processado corretamente.
								---> fixado, o token da expressao apos operadro @ estava deixando um token virgula, que deveria ser deletado.
								---> falha no metodo de encontrar um método compativel com os parametros da chamada.
											--->fixado, o elemento de expressão formado com o operador @ deveria ser do tipo string, pois é um texto literal sendo passado como parametro, e está como tipo int no processamento de Expressao.ExtraiExpressoes().
											--->a ordem de expressoes da instrução está errados. fixado havia uma associacao para a expressao de saida, como as expressoes parametros, devido ao nome serem muito parecidos. E tambem a lista de saida não estava como a lista de saida, mas como a lista de parametros, justamente porque os nomes eram muito parecidos.

					---> (testado) testar a classe PosicaoECodigo.
								----> fixado, o teste no cenario mais simples passou.
								----> fixado, estava passando para a proxima linha quando localizava o token currente). teste mais complexo passou.


__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 06.07: 


					---> parada para escrever cenarios de texto para executar um programa VM Orquidea.
					---> documentação das funcoes LISP e PROLOG.
					---> escrever instrucoes que processam funcoes LISP e Consultas PROLOG como instrucao OO orquidea.

					----> (feito, aguardando testes) simplicação na construcao de operadores, mais facil de extender mais operadores, e ganho de velocidade de processamento.
								----> operadores definidos por api reflexao, eliminando calculos com operandos colocados em pilha.
								----> (codificado) codificar teste para calculo de uma expressao.
								----> (modificacao) classes Matrizes com operações iguais, excluindo classe MyMATRIX.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 07.07: 
					---> fixado o metodo de obter operadores nativos.
								----> há duas implementações de operadores que deveria ser verificado: ObjectA, e List ObjectA.
										---> os dois metodos importados são da classe base _Operadores().

					---> testes para avaliar expressoes, falha, na operacao em EvalExpression(). Investigando, a operacao + não está sendo calculada corretamente.
								---> (fixado) o método ExtraiExpressoes está quebrado novamente! está retornando a expressao numa lista de elementos, cada um formando uma expressão.
								---> a expressao formada não está sendo avaliada corretamente: retorna resultado: 1, e o resultado esperado é 3.
											---> falha na obtencao do operador "=" em Expressao.ExtraiExpressao().
											---> falha está na obtenção do tipo de retorno da expressao.
											---> fixado o tipo de retorno da funcao (tipo dos elementos da expressao, sob casting).
											---> fixado o metodo linguagemOrquidea.GetOperador().
											---> a falha no metodo eval() está na nao atribuicao de valor na instrucao de atribuicao.
											---> o bug é conceitual: uma expressao com operador "=" retorna null, pois o primeiro elemento da expressao tem o valor a determinar justamente pela eval()...

					---> fixar as expressoes para retirar atribuicao e operador "=" das expressoes.

					---> o objeto caller, que invoca a funcao do operador, nao esta inicializado corretamente. É preciso construir um novo objeto caller.
											---> objeto caller é construido na inicialização do Operador. Um operador não precisa ter parametros no construtor, apenas parametros quando é executado.
											---> verificar se o caller para metodos importados está corretamente construido.

					---> (fixado) ao modificar como o objeto caller é instanciado, o construtor de Funcao para Reflexao quebrou! Há confusão entre os parametros para o construtor e parametros da chamada da funcao.
											---> simplificado o metodo de OperadoresNativos.GetImplementacao(), com um switch verificando os nomes dos operadores.


_____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 08.07: 

					---> testes para avaliação de expressoes, os objetos callers estão sendo instanciados.
								----> na extração de expressões, os tipos de cada elemento está retornando null.
								----> os valores de variaveis em debug estavam setados para o tipo string! Foi feita a conversao para tipo Int32 ou float, se o valor for um numero.
											----> (ATUALIZAR) atualizar todos builds de atribuicao, para converter em debug o valor de variavel, se o valor for um numero.
								----> para valores em modo debug, o teste do cenario mais simples de avaliar uma expressao, passou...



					----> codificado no metodo OperadoresNativos.GetImplementacao(), para não incluir metodos da classe base, _Operadores.

_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 09.07: 		

					----> (ATUALIZADO) atualizar todos builds de atribuicao, para converter em debug o valor de variavel, se o valor for um numero.
								----> metodo de conversao: ProcessadorID.SetValorNumero().


					----> estudar a possibilidade de compor valores de variaveis para numeros inteiros, nao como int mas como Int32, o tipo Int32 é utilizado em operadores importados, e praticamente todos operadores nativos...
					----> (codificado) compor cenario mais complexo possivel, para avaliar uma expressao, como utilizacao de uma funcao para um dos operandos.
								----> (fixado) fixado o tipo de operador, o metodo OperadoresNativos.GetImplementacao() não estava retornando o tipo de operador (BINARIO,UNARIO).
												---> na classe LinguagemOrquidea, estava definindo erroneamente o tipo de operador.

								----> (fixado) testes, falha no processamento de definicao de funcao: está registrando duas vezes uma mesma funcao. fixado, O registro da funcao estava sendo feito duas vezes..
												---> (fixado)falha no metodo Expressoes.ExtraiExpressoes(), o caso de token="(", não está processando corretamente.linha 530,  classe Expressao.
																---> fixado, nao havia processamento quando havia um token de funcao entre os parenteses. funcaoA(x) retirava "funcaoA(x", e nao "funcaoA(x)".
																---> refatorado o metodo ExtraiExpressoes, ha um caso em que processava uma chamada de funcao quando encontrava um token "(", que nao faz sentido,
																pois é quando um token ")" encontrado eh que se devia ser processado a chamada de funcao.
																---> fixado metodo GetFuncaoCompativel() nao estava retornando uma funcao quando a expressao da chamada fosse um numero.

								---> metodo Expressao.ExtraiExpressoes() fixado.

					---> teste para o cenario mais complexo possivel, falha na colocacao da expressao do teste para pos-ordem.
								---> a falha esta no metodo Expressao.ExtraiExpressoes(), que nao está registrando um parametro numero de uma chamada de funcao.
												---> verificar a linha de Expressoes: linha 563, é preciso incluir as expressoes dos parametros da chamada de funcao, como parâmetros da função-expressão.

								---->(codificado) o tipo ExpressaoFuncao esta incompleto, eh preciso incluir as expressoes que compoem os parametros da chamada de funcao.
												---> codificado o retorno de texto descritivo da ExpressaoChamadaDeFuncao.

												---> fixado, aguardando testes com cenario de teste o mais complexo possivel, para o metodo EvalExpression().
												---> com o tipo ExpressaoFuncao, renomeado ExpressaChamadaDeFuncao, porque é uma chamada de função dentro de uma expressão, e não a execucao de uma funcao, e os parametros? Estava incompleto o esboço...

					----> testar o cenario mais complexo possivel para avaliacao de uma expressao...


_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 17.07: 		
					----> teste do cenario o mais complexo possivel para avaliação de uma expressão.
							----> fixado o bug do metodo Expressao.ExtraiExpressoes(), na composicao de funcao compativel com a chamada de funcao em uma expressao.
							----> (fixado) metodo ExtraiExpressoes() está retornando a lista de expressoes um nivel mais baixo...
							----> (fixar) metodo Expressao.PosOrdem() quebrou! Copia da expressao de retorno estava copiando itens nulos da expressao que chamou o método.
											----> modificado o metodo PosOrdem(), para compor uma expressao de retorno limpo, sem elementos...

					---->(verificado, codificado um metodo novo) o metodo Expresssao.PosOrdem() foi construido antes da formação de uma expressão por um construtor que classifica cada
					elemento como variavel, operador, chamada de função, etc... fazendo o metodo ser muito mais complexo, do que a analise baseada
					nos tipos dos elementos da expressao...
								----> Construir o metodo Expressao.PosOrdem(), com analise dos elementos da expressao. O metodo sairá
											limpo, sem muitas voltas: 
												1- empilhar enquanto for um elemento variavel;
												2- a cada elemento operador, empilhar na pilha de operadores, se o operador do topo da pilha for de prioridade menor que o operador
											currente da analise, ou desempilhar o operador no topo da pilha e dois elementos (se o operador for binario) 
											se a prioridade for maior que o operador currente da analise; 
												3- Verificar se ha parenteses, que elevam a prioridade;
												4- Se for chamada de funcao, imediatamente fazer a PosOrdem() nos parâmetros da função,
												   e depois colocar na expressao pos-ordem,	a chamada de funcao. 
												5- Operadores binario e unario ao mesmo tempo, deverá ser feito uma analise,
											sobre qual tipo do operador, se for como binario, ou se for como unario, se for unario, elevar a prioridade do operador;
								
								A analise sairá limpo, direto, como o algoritmo pos-ordem original é..., graças a montagem nos elementos da expressao
								no seu construtor. A maravilha em colocar a expressao em pos-ordem, e que o processamento de avaliação do valor da 
								expressão é rápida,	simples de construir e manter a legibilidade do codigo, permitindo uso de parenteses, chamadas de função,operadores binarios
								e unarios...



					----> (codificado) metodo Expressao.PosOrdem() codificado totalmente.
					----> (codificado) um novo insigth verificou-se que o metodo ExtrairExpresoes() estava muito grande, de dificil legibilidade e consequente dificuldade para conter novos tipos de tokens delimitadores de expressoes,
					alem do que estava duplicado: o construtor de Expressao() fazia o mesmo processamento, com excessão de que constroi apenas uma expressao por vez.
					foi alterado o construtor para estabelecer o indice do ultimo token da expressao construida, e o metodo ExtraiExpressoes(),
					graças a este indice, pode ser resumido muito, tornando-se intuitivo, legivel, mas dependendo de eventuais mudanças, deverão
					ser feitas no construtor de expressoes.
		
					----> faltando no construtor outros tokens finalizadores de expressao: 
							1---> "(", ")": codificado.
							2---> ",": a codificar. (o operador virgula faz parte de chamadas de função, porém pode surgir como delimitador de objeto em dicionarios, mapas, etc...
							


				    ----> generalizar a construcao de operadores nativos, contendo: nome do operador, nome do metodo implementador...
			
		lista de funcoes lisp: (documentacao do projeto)
		/// COMANDOS LISP:
        /// 1 - Maior(): >
        /// 2-  Menor(): <
        /// 3-  MaiorOuIgual(): >=
        /// 4-  MenorOuIgual(): <=
        /// 5-  Igual(): ==
        /// 6-  Cond()
        /// 7-  if()
        /// 8-  car()
        /// 9-  cdr()
        /// 10- Quote()
        /// 11- OperacaoMatematica(), em listas LISP : subtracao, Adicao,Multiplicacao, divisao(com nomes como: +,-,*,/, etc..
        /// 12- cons()
        /// 13- Atomo()
        /// 14- Member()
        /// 15- Setq()
        /// 16- IsAtomo()
        /// 17- CondicionaIgual(): ==
        /// 18- CondicionalMaior(): >=
        /// 19- CondicionalMenor(): <
        /// 20- CondicionalMaiorOuIgual(): >=
        /// 21- CondicionalMenorOuIgual(): <=
        ///  funções lisp no interpretador possuem recursividade, para Funcoes Lisp construidas pelo programador-cliente.
		
		
		/// COMANDOS PROLOG:		
	    // 1- asserta(Predicado): adiciona o [Predicado] no inicio da lista de Predicados da Base de conhecimento. (feito)
        // 2- assertz(Predicado): adiciona o [Predicado] no fim da lista de Predicados da base de conhecimento.(feito)
        // 3- listing(nome): lista os predicados ou regras como nome [nome]. (feito)
        // 4- predicadoA(data(A,C)): define um objeto registro de nome [data], com campos [A] e [C].
        // 5- listas em PROLOG.
        //      5.1- [], uma lista vazia.
        //      5.2- [X|Y]: é uma lista vazia, [X|Y], com X= cabeça, e Y= calda (restante da lista após a cabeça).é uma lista com pelo menos um item.
        //      5.3- [X,Y]: lista com dois itens.
        // 6- tell(arquivo, Predicado(X)),told: grava em arquivo os Predicados entre tell e told, cujos predicados combinam com [Predicado].(feito).
        // 7- consult(arquivo): carrega em arquivo os Predicados gravados em arquivo.(feito)
        // 8- retract (predicado para consulta), que exclui predicados, da base de conhecimento.(feito)
        // 9- Is (seta uma variável com um valor).
        // 10- comparacao (compara duas variáveis).



        // funcionalidades de ComandosProlog:
        // 1- AdicionaFuncionalidade(): torna a linguagem estendível, seguindo o padrão de projeto Command.
        // 2- IsComando(): retorna [true] se o predicativo linha de texto da entrada é um comando da linguagem.
        // 3- ExecutaComando(): executa o método associado ao comando predicado.
        // 4- métodos de comandos pré-definidos em ComandosProlog.

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 18.07: 	

			----> loop infinito no metodo Expressai.ExtraiExpressoes(), não há incremento da malha do processamento dos elementos da expressao que chamou o metodo.
							---> o processamento de extracao de expressoes está extraindo tambem operadores virgula, nas chamadas de função.
						    ---> o método também não está extraindo variaveis apos o processamento de extração de expressoes de chamada de função.(fixado, num dos casos de formação de expressão estava com um acrescimo na variavel da malha, com uma lista de tokens incorreta, era outra lista de tokens).
			---> fixado, o teste com cenario mais complexo possivel para extrair expressoes, passou. 
				no texto de toString(), para chamadas de função, está retornando um conjunto de parenteses extra, e os parametros não estão aparecendo na chamada de função.

							----> (fixado) fixado a mostragem de elementos-parametros no texto descritivo de ExpressaoChamadaDeFuncao,
								  (fixado) porém está com um par de parênteses a mais.
							----> (verificado) está retornando corretamente o tipo da expressão.
							----> (fixado) a mostragem de um conjunto de parenteses no texto descritivo: na classe base Expressao, estava retornando no metodo .ToString(), o conjunto de parenteses a mais..


			----> modificado como um operador é executado: o resultado da operação é convertido para o tipo de retorno do operador.
							----> modificado o metodo CastingExpressao() que retorna "float" se algum dos numeros da expressao for um  "float" se algum dos numeros for "float" e nenhum dos objeto for um objeto de classe nao inteira.
			---> metodo ExtraiExpressoes() com mudanças no código, tornando muito mais legivel, menos propenso a erros, e se duplicação de código, junto com o construtor Extracao(),
			está operacional.


			----> (a fixar) continuando o testes de avaliacao de expressoes, depois da fixação do método Expressao.PosOrdem(),
			falha, a expressão não está retornando em pos-ordem, retorna uma expressao vazia...
							---> verificando o comando anterior da execução do metodo Expressao.PosOrdem() esta resultando uma expressao vazia...
							---> fixado o erro de expressao vazia, estava chamando o metodo Expressao.PosOrdem() estava sendo executado como um metodo estático...
							---> (fixado, a variavel da malha nao estava sendo incrementada) testes para metodo PosOrdem(), falha, entrou em loop infinito...
							----> fixado, o teste para o metodo Expressao.PosOrdem(), para um cenario simples, passou... e com apenas uma fixação, o incremento da variavel da malha...
											---->o método Expressao.PosOrdem() foi recodificado totalmente, e obteve exito com poucas fixações...
												 o codigo anterior do metodo nao estava utilizando os tipos de expressao feitas no construtor da expressao, o
												 que com a recodificação chegou-se a um metodo que funciona, mais simples, mais intuitivo, e de legibilidade melhor, o que facilita futuras modificações, passando por dentro do metodo...


					----> pronto para a avaliacao do metodo EvalExpression(), para o cenario simples.
							---> teste para avaliação do metodo EvalExpression.Eval(), para o cenario simples, passou...
							---> houve um significativo aumento na qualidade do codigo, menos erros, talvez seja o foco que está melhorando...
											----> o foco melhorou quando começou-se a utilizar a lógica de programação básica, como uso de if/else aninhados, enfim, lógica de programação que todo programador deve saber.
												  a utilização de lógica de programação como se conhece, gera "bônus" quando escrevemos codigo seguindo a lógica de programação que aprendemos há mais de décadas...
_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 20.07: 	

		----> executar o cenario de teste mais complexo possivel, para avaliação de expressões..
		----> testes, falha, nao esta carregando o valor de parametro de uma expressao dentro de um corpo de função.
							
							----> codificar a passagem de valores em parâmetros de função, na execução de uma função.

							----> no Build de DefinicaoDeFuncao, e DefinicaoDeMetodo, retirada a deleção das variáveis 
							parâmetros, no escopo da função. Isto é para instrucoes como "return", que ficam aninhado
							dentro do corpo de uma função. Uma desvantagem é que nenhuma outra variavel dentro do escopo,
							não poderá ter o nome da variável parametro.
										----> uma solução seria incluir um escopo personalizado, para instruções de chamada
										de função, ou chamada de método, e outras instruções como "return", mas é dificil no 
										caso da instrução "return", compor um escopo personalizado, pois não há acesso ao
										escopo da função que contém a instrução "return".
							---->escolha pelo metodo mais simples: registra as variaveis parametros, no escopo.
							Foi parcialmente codificado a solução, faltando a associação do valor ao parâmetro de função.

							---> testes, falha na execução da instrucao do corpo da função, justamente porque havia 
							codigo antigo, com processamento de retorno de endereço de função por pilha, o que não
							foi implementado totalmente, e adotou-se outro tipo de estratégica de retorno de valor 
							pela expressão "return".
										
							---> fixado com modificações no acrescimo de variaveis parametros no escopo do programa,
							o teste para cenario o mais complexo possivel, passou...


		----> (codificado) codificar uma classe de testes para teste de muitos tipos de avaliação de expressões, para cobrir a maior
		parte possível do código para execução de expressoes....

		---> (codificando) uma classe de testes, para todos tipos de instruções a serem processadas por um ProgramaVM.
							----> codficacao para instrucoes "if", "if/else", "for", "while"; instrucoes de atribuicao ja foram testadas
								  em muitos outros testes. também as instruçoes: build funcao, build metodo, build classe, já foram testados 
								  tb varias vezes.

		-----> estudar a inclusão de um escopo para uma funcao, que guardaria não só as propriedades do corpo da função, mas também os valores dos parametros da função!,
			   isto eliminaria a inclusão do escopo principal as variaveis que formar os parametros.
			   (estudado, implantado) isto abrange o conceito de escopo e visibilidade: cada funcao terá um escopo, que permite criar variaveis dentro do corpo da funcao,
			   e registrar variaveis- parâmetros no escopo da funcao, eliminando o acrescimos de variaveis parametros no escopo principal do programa.

		(mudanca no codigo de definicao de funcao/metodo).
				---> para funcoes/metodos nao houve modificacoes, independe do escopo para fazer o processamento.
				---> para funcoes/metodos construidos na linguagem, o escopo foi atualizado no build da definicao da funcao/metodo.
				---> modificado os builds de funcao/metodo, para compor com o escopo da funcao, as instrucoes dos metodos/ funcoes.

		----> (falha nos testes) com as modificacoes de escopo de funcao feitas, teste para cenario simples, passou, mas teste para cenario complexo para expressoes, falha...	
						----> o tipo de operador, obtido pela linguagem, está retornando null...
						----> fixado, primeiro determina o tipo da expressao, depois faz o processamento de elementos da expressao.
						----> com a modificação do código, novos testes. Teste para calculo de expressao cenario simples, passou...
						----> (falha no teste cenario mais complexo): falha na execução de um programa na VM, o conjunto de instruções não está retornando um valor.
										----> (fixado, a retirada dos parametros do escopo principal estava antes da copia para o escopo da funcao) verificando o escopo da função está quebrado! Nao há registro da variável parâmetro no escopo da função...
										----> (falha, fixado), a associação do valores dos parametros no escopo da função, quando se executa a função, não está registrando..

						----> pronto para continuar o teste para cenario mais complexo possivel, fixado o carregamento de parametros no escopo da função.
										----> variaveis simples, variaveis vetor, tem suporte na execução da função, carregando os valores dos parametros para as variaveis registradas na tabela do escopo da funcao...
										----> avaliação de parametros de uma chamada de funcao para qualquer tipo de dados, nao so valores numeros resultante do calculo para parametros.

						----> teste para avaliacao de expressao, no cenario mais complexo possível, passou...

	
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 21.07: 	
			
			----> testar cenario de testes de expressoes, com classe de testes.
					---> falha, justamente por não incluir o operador de atribuicao "=", na lista de operadores nativos.
					---> falha, a obtencao do tipo da expressao não está registrando corretamente.
								---> fixado, extensao de tipo de dados para o tipo da expressao extendida para nome de classes, nome de variaveis, nome de variaveis vetor, nome de objetos.
								---> falha no processamento de parametros de uma chamada de função.
								---> tentativa de fixar, mas o processamento dos parametros de uma chamada de função, não está retornando valores, mas o nome das variaveis dos parametros.
												----> fixado, mas a situação da avaliação de parametros - expressao nao esta suficiente para calculos mais complexos...
	
						

			----> testar cenario de testes de instrucoes, com classe de testes tb.
___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 22.07: 	

	Atividades do Dia:
		1- fazer passar o teste para o primeiro cenario teste da classe ExpressaoTeste.


				----> tentativa de inserir os valores de parametros, na execução de uma chamada de função, falha.
			      (fixado com novo metodo em UtilTokens) nao há vinculo entre os parametros passados, e os parametros da função.
			
				----> o operador "=", nao esta associando o valor da pilha de operandos, para a variavel a ser atribuida.
				 (fixado, o ultimo operando para a atribuicao esta no elemento[0] da expressao a ser avaliada, pois possui o menor indice de prioridade.)
			
				----> correção dos valores parametros certo, correção da atribuicao do operador "=", certo.
					falha no calculo dos parametros da chamada de funcao. O valor do segundo parametro está com o valor do primeiro parametro...
					----> pausa escrevendo o problema para tornar visivel a resolucao, falha no metodo UtilTokens.LoadParameters(), na atribuicao do segundo parametro.
					----> investigando, a falha nao esta no metodo LoadParameters(), mas na atribuição de valores na construcao de inicializacao de variaveis, com atribuicao.
								----> é um problema sutil, os parametros-expressao da chamada de função não estão sendo inicializados com os valores da expressao.
										----> codificado o carregamento de valores para as variaveis que sao nomes de parametros da chamada de funcao.
										----> falha, codificar para modificacao da expressoes da instrucao contendo valores de parametros de chamada de função.
										----> falha na estrutura da classe de testes: não está inicializando o objeto Assercoes.assercao, na inicializacao da classe SuiteClasseTestes...
										----> falha na construcao da assercao, o resultado de avaliação de expressões é um objeto, que deve ser convertido no tipo da expressao, a partir do texto do objeto.

				----> falhas em passagem de parametros para dentro das expressoes da chamada da função, falha na classe SuiteClasseTestes, na constituicao da assercao em cada teste da classe.
				----> fixado tudo, o teste cenario 1 para avaliação de expressões passou.....
___________________________________________________________________________________________________________________________________________________________________
Daily Scrum 23.07: 	

	Atividades do Dia:
				2- Fazer passar o teste para o segundo cenario da classe ExpressaoTeste.
					----> verificar se objetos importados são acrescidos como objeto propriedade.
								----> verificado, nao há verificação para o tipo de variavel nos builds de declaracao de variavel/variavel vetor.
								----> acrescentado a verificação do tipo de variavel nos builds de declaracao de variavel, no repositorio de todas classes, importadas ou não...

					---> iniciado testes, falha no reconhecimento do tipo "float".

				3- Fazer passar o teste para o terceiro cenario da classe ExpressaoTeste.
					----> iniciado testes, falha no reconhecimento da sequencia id "return".	
							----> a falha está no método "ProcessadorID.SimplificarUmaExpressaoSemTermosChave()", está
							incompleto, não contém resolução para ids=operadores binarios. Está relacionado com a aparição de parenteses na sequencia de ids de "return".
							----> substituicao no metodo ProcessadorID.MatchSequencias() para reconhecer producoes da linguagem.
								----> com essa modificação, o problema relatado irá se resolver...

					
					**- (implementado, testado) (IMPLEMENTAR URGENTEMENTE)----> correção para o problema da instrução "return": se o inicio da sequencia currente for uma palavra-chave, retorna
					true para o match de sequencia, e deixa para o build da instrução validar a sequencia id.

				---> o problema com Garbage Collector, que vinha implicito com a implementação da linguagem base, não é preciso, pois a cada nova instanciação de uma variável com mesmo nome, modifica-se o valor.
								----> verificando se arrays e listas cumprem esta ideia.
								*----> (IMPLEMENTAR) setar na instrucao atribuição de variáveis, de variaveis vetor, os indices de matriz.
____________________________________________________________________________________________________________________________________________________________________________________________________________________________					
Daily Scrum 24.07: 	

	Atividades do Dia:
	
				Resumo, sem o fluxo de comunicações:

				----> testar cenarios de teste da classe TesteExpressoes.
				----> (IMPLEMENTAR) setar na instrucao atribuição de variáveis, de variaveis vetor, os indices de endereçamento de indices do vetor.


				Atividades fluxo feitas:

				----> (testado) continuando o cenario de teste 2:
						----> fixado o metodo Expressao.ExtraiExpressoes(), para expressões com parenteses.
						----> teste para o cenario se teste 2 passou.
						----> devido a mudança no código, testado o cenario de teste 01 e passou tb...

				----> (implementado) implementado o match de sequencia id com palavras de comandos como comeco da sequencia id.

				----> (fixado, testado) continua com testes para cenario de teste 2o.
							----> validando a mudança no método ProcessadorID.MatchSequencias() segue com consistência.
							----> falha no Expressao.ExtraiExpressoes no build de "return". Havia um caso em que não estava retirando uma expressão entre parenteses, sem ser uma chamada de função.
							----> fixado, o teste para o cenario de teste 2o, passou....



				----> teste para cenario de teste com tipo de dados com float, falha no reconhecimento de tokens das instruções...
							----> verificar se a obtenção de tokens está sendo processado corretamente.
										----> metodo ParserUniversal.GetTokens() quebrou!:
										      falha na obtenção de tokens com numeros float: o operador "." esta fora do numero float...
											  (fixado) o operador "." estava previsto como token polemico, porem retornava false para qualquer situação, nao havia logica associada....

							----> fixado o metodo ParserUniversal.GetTokens(), falha na atribuição de variaveis "float".
										----> falha na conversao de uma string para o tipo float.
						

				----> (fixado)(fixando testes, falha na conversao de strings em floats) Fazer passar cenario de testes 3, com expressão floats.
							----> iniciado cenario de testes 3 da classe TestesExpressao.
							----> testes para cenario de teste 3 passou. Houve dificuldade na declaração de uma string de numero float, que depende da CultureInfo.
							
				
_____________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 26.07: 	

	Atividades do Dia:
				---> verificar a criação de variaveis vetor, com expressoes definindo indices. Necessario verificar a instrucao Create(), para criação de objetos das classes construidas com linguagem de OO.
				---> iniciar testes da classe TestesInstrucoes.

				----> planejamento do operador matricial: novo tipo de expressao...
				----> planejamento do problema de multiplias chamadas de um mesmo escopo de função: implementar um contador para variaveis de um escopo de função.
								----> para cada entrada de execução de função, um contador é aumentado. Se voltar a executar a função, o contador é atualizado...
______________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 27.07: 	
				
	Atividades do dia realizadas:
				----> implementação do operador matricial.
						----> o codigo do construtor de Expressao estava com muitos erros de identificação de tokens, estavam em blocos de código dentro de outros blocos de codigo..., escondendo o processamento correto dos tokens que formam a expressao construida.

				----> adição de uma instrução de construcao de uma variavel vetor.
				----> modificações na classe variavel vetor. construcao de indices matriciais, para localização dentro do vetor.
						---> (fixado) do jeito que está é impossível localizar um elemento dentro de outro elemento do vetor.
						---> suporte para acesso com indices de dimensões, como [3,2,5], ou como [[3,2],5].


				----> inicio dos testes da classe TestesInstrucoes.
						---> falha no metodo ExtraiExpressoes: o codigo foi corrompido!!! Relatado modificações no método ExtraiExpressoes, com codigos embaralhados, e sequencias erradas!!
										----> nao ha duvida! o codigo foi sabotado, instrucoes estranhas, dificilmente de se codificar incorretamente, foram econtrados... jacobinos a vista!!
                        				----> o operador "++" está como "++;".
										----> fixado o bug.

						---> fixado o bug de obter operadores no construtor de Expressao.
						---> o metodo Expressao.GetTipoExpressao() não está funcionando.
										---> removido o metodo GetTipoExpressao().

						---> falha no metodo de construcao de blocos, na instrucao "for".
										---> metodo Expressaio.ExtraiExpressoes() nao esta extraindo a expressao de atribuicao corretamente. Construtor Expressao na esta construindo a expressao de atribuicao corretamente. fixado um "else" estava incluindo duas vezes a mesma variavel: uma da variavel ja declarada, e uma de id não inicializado.

					    ---> processamento de instrucao "for", sem execução do programa VM, passou.
						---> processamento de instrução "while", sem execução do programa VM passou.
						---> processamento da instrução "if", falha não está reconhecendo a instrução do "if". fixado (cenario de teste estava com um ponto e virgula a mais no final do bloco de instrucoes). processamento sem execução da instrução passou...
						---> processamento da instrução "if/else", falha não está reconhecendo o segundo bloco de instruções, o bloco da instrução "else".
										---> é um problema serio: falha na construção da sequencia currente: está quebrando o "if/else" em duas sequencias. porque a sequencia id termina com um bloco "{}", e nao deveria terminar com o bloco "{}", deveria continuar o processamento. fixado, o termino de sequencias id não acaba com o termo-chave bloco {}.
										---> continua a falha: o bloco do "else" nao está sendo processado...
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 28.07: 	
				
	Atividades do dia realizadas:
						----> testes para instrução "if/else", fixado, passou...
						----> Verificar se as expressoes estão sendo divididas quando encontra um operador "=", no construtor Expressao.Expressao(), pode haver quebra de codigo se a instrução de atribuição não processar as duas expressões (1 de declaração, e 1 de atribuição).
										---> verificar a instrucao "Atribuition. Verificado, há uma divisão explicita entre os tokens de definicao e os tokens da atribuicao. Foi removido esta divisão. Eh que o metodo EvalExpression versao anterior nao tinha suporte para atribuir valor na variavel a ser atribuida (operador "=").
										----> a expressao de declaração de propriedade está inserindo dados da expressao de atribuicao. Remover os dados da expressao de atribuicao da expressao de declaração.


						----> completado a instrução "atribution", para construir objetos de classes orquidea. 
										---> COMPLETAR OS BUILDS ATRIBUICAO, PARA COMPOR TAMBÉM OBJETOS, COM UM CAMPO EXTRA: propriedadeASerModificada, Builds que constroi Objetos devem ser modificados para compor uma propriedade de atribuicao.

						----> registrar cada expressão de instrução, no escopo currente, a fim de otimização de expressões.
										---> codificado o registro de expressoes para as instruções, menos para instrucoes de definicao de funcoes/metodos (que nao possui expressoes que variam), definicao de operadores binarios, unarios.


_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 29.07: 	

	Atividades do dia realizadas:
						----> metodos para variavel vetor.
										---> é preciso ter instruções para dois tipos de vetor: vectorMatrix, vectorJagged.
________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 30.07: 	

	Atividades do dia realizadas:

						---> testes para instruções, compilação e interpretação do programa VM gerado.
										---> testes para instrucao "for", falha no metodo Expressao.PosOrdem(): não está registrando a variavel "x" da expressao: "x<2".
											---> fixado. codificado tb o calculo do limite da variavel da malha "for".
											---> no metodo EvalExpression(), inclusao se a expressao for um token de numero.
													---> falha estranha, os operandos numeros estao sendo convertidos em strings.fixado.
											---> o loop da instrucao "for" está ocorrendo, mas os calculos das instrucoes da malha não estão correto.
											---> (fixando) um erro conceitual: o contador de instruções está sendo atualizado dentro dos loops. Cada bloco contem um ip proprio, pois nao estao na lista de instrucoes do fluxo principal...

						----> fixar o contador de instruções: deve ser atualizado somente no fluxo principal de instruções.
						----> a expressao de incremento da malha nao esta atualizando a variavel da malha!.
											----> mais clarificação: toda variavel com operador unario recebe valor durante a avaliação da expressão currente!!
											----> o interessante é que as regras de avaliação de expressão funcionam mesmo quando nao codificamos o tratamento para a expressao. eh o caso da avaliação de expressão com operador unario.

						----> teste para instrução "for", com compilação e execução do programa VM, passou.
						----> refatorado a execução de blocos de instrucoes, tendo um metodo proprio para processamento.
											---> fixado instrucoes: "while", "if/else", "for". modificacao feita, teste "for" novamente passou.


						----> teste para instrução "if/else", compilado, executado o programa VM, passou.
						----> teste para instrução "if", nao passou: o codigo do metodo Expressal.PosOrdem() quebrou!
											---> (fixado) saida inválida para expressao c=3*b, resulta em "c 3 = b * ". O código para operadores ainda na pilha tem que ser movidos por pop() da pilha, e não na ordem de inserção (fila).


__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 31.07: 	

	Atividades do dia realizadas:
						----> fixado as instruções, testes com compilação, e execução do programa VM, para "for", "if/else", "while", "if",atribuicao, testes passaram...
						----> (codificar) cenario de teste para instrução casesOfUse.
						----> codificado o problema das variaveis locais, stack, para execução de uma função com escopo em cada chamada de função: a cada execução, carrega-se o conjunto de variáveis locais, para o escopo da função...
										---> a verificar se o escopo de cada chamada de função/método está recebendo uma cópia da lista de variáveis locais...
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 03.08: 	

	Atividades do dia realizadas:
						----> fazer passar o cenario de testes para instrução caseOfUse.
										---->(fixado) refatorado o build da instrução casesOfUse, tornando com menos indices, mais legível e menos bugs ocultos.
										---->(testado) a execução da instrução casesOfUse, no programa VM. o cenario é com uma condição meio boba: b>b, que resulta sempre em false.
													----> (testado) testar para uma instrução com case mais possível, para o processamento do bloco de instruções do case.
						---> instrução casesOfUse passou nos testes, de build, e de execução.

__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
Daily Scrum 04.08: 	

	Atividades do dia realizadas:
						----> testes para a classe importer, falha ao determinar o objeto que chamará a execução do metodo via reflexao.
										----> falha na construcao do objeto caller que chama a execução do método.
										----> fixado a classe importer, apenas não calcula mais o objeto caller, para a chamada de método.

												----> um erro conceitual: calcular os parametros para a instrucao create, no Build, fixado, deixado para o processamento da instrucao create.
												----> falha na determinação de encontrar o construtor correto para a instrucao create, devido ao calculo como inteiro como "int" e "Int32".
										----> fixado, a instrução "create" e "importer" estão operacionais. (2 testes para importer).

						---> verificar o tipo double no processamento de expressoes. Na construcao de parametros, deve-se converter "double" para "float".

						---> testes para processamento de uma chamada de metodo, de um objeto de classe importada.
										----> falha ao tentar encontrar o metodo tratador para a chamada de metodos (metodo MatchSequencias()).
												---> fixado, o metodo MatchSequencias() não estava processando ids como nomes de função, de objetos, de métodos, de propriedades...

										----> falha no metodo "ValidaPropriedadesEncadeadas()", não está obtendo a variavel de chamada do metodo.
												---> fixado, o build de create nao estava registrando a variavel no escopo.

										---->(a testar) falha ainda no metodo "ValidaPropriedadesEncadeadas()". Verificando o codigo nao importou as classes do importador de classes...
												---> fixado, o build do importador carrega previamente as classes de um assembly.
												---> falha na manipulação de tipos double no metodo "ValidaPropriedadesEncadeadas()".
											    ---> o parser universal não está registrando um numero float: "1.0", e sim "1",".","0".
														--> fixar o parser universal.GetTokens(), para quando encontrar um termo ".", se o token anterior for numero, anexar dos tokens numero a seguir após o termo ".".
																	---> codificado a obtencao de numeros flutuantes, aguardando testes e anexar o metodo ao ParserUniversal.GetTokens().
																	---> (a testar) teste para expressoes fixado, para o metodo da classe testes de instruções, verificar se a obtencao de numeros flutuante está ok...

					    ---> verificar se a classe Objeto não é uma classe redundante, se há a possibilidade de concentrar as propriedades na classe Variavel.
						---> validado se as dimensoes passadas para uma variavel vetor se é igual a null, setando se null para uma dimensão.
												--->(a fazer) alterar o metodo do build da instrução "create" obtem os indices, a partir das expressoes parametros, quando a variavel a ser criada for uma VariavelVetor.

	Atividades pendentes:
			---> teste para processamento de uma chamada de metodo de um objeto de classe importada.
						---> (teste implícito) modificado o codigo de ParserUniversal.GetTokens(), para corrigir erros com tokens de ponto flutuante.

			---> fixar o build da instrução "create", para retirar indices de dimensões, se a variavel a ser criada for uma variavel VariavelVetor.
						---> codificado, aguardando testes.
__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
